# 50.6 Crash Recovery  

From the description above, you might sense that crash recovery is more involved than with NFS. You would be right. For example, imagine there is a short period of time where a server (S) is not able to contact a client (C1), for example, while the client C1 is rebooting. While C1 is not available, S may have tried to send it one or more callback recall messages; for example, imagine C1 had file F cached on its local disk, and then C2 (another client) updated F, thus causing S to send messages to all clients caching the file to remove it from their local caches. Because C1 may miss those critical messages when it is rebooting, upon rejoining the system, C1 should treat all of its cache contents as suspect. Thus, upon the next access to file F, C1 should first ask the server (with a TestAuth protocol message) whether its cached copy of file F is still valid; if so, C1 can use it; if not, C1 should fetch the newer version from the server.  

Server recovery after a crash is also more complicated. The problem that arises is that callbacks are kept in memory; thus, when a server reboots, it has no idea which client machine has which files. Thus, upon server restart, each client of the server must realize that the server has crashed and treat all of their cache contents as suspect, and (as above) reestablish the validity of a file before using it. Thus, a server crash is a big event, as one must ensure that each client is aware of the crash in a timely manner, or risk a client accessing a stale file. There are many ways to implement such recovery; for example, by having the server send a message (saying “don’t trust your cache contents!”) to each client when it is up and running again, or by having clients check that the server is alive periodically (with a heartbeat message, as it is called). As you can see, there is a cost to building a more scalable and sensible caching model; with NFS, clients hardly noticed a server crash.  

OPERATINGSYSTEMS[VERSION 1.10]  

<html><body><table><tr><td>Workload</td><td>NFS</td><td>AFS</td><td>AFS NFS</td></tr><tr><td>1. Small file, sequential read</td><td>Ns . Lnet</td><td>Ns . Lnet</td><td>1</td></tr><tr><td>2. Small file, sequential re-read</td><td>Ns . Lmem</td><td>Ns . Lmem</td><td>1</td></tr><tr><td>3. Medium file, sequential read</td><td>Nm . Lnet</td><td>Nm . Lnet</td><td>1</td></tr><tr><td>4. Medium file, sequential re-read</td><td>Nm . Lmem</td><td>Nm : Lmem</td><td>1</td></tr><tr><td>5. Large file, sequential read</td><td>Nt . Lnet</td><td>NL . Lnet</td><td>1</td></tr><tr><td>6. Large file, sequential re-read</td><td>NL . Lnet</td><td>NL  Ldisk</td><td>Ldisk</td></tr><tr><td>7. Large file, single read</td><td>Lnet</td><td>NL . Lnet</td><td>NL Lnet</td></tr><tr><td>8. Small file, sequential write</td><td>Ns . Lnet</td><td>Ns . Lnet</td><td>1</td></tr><tr><td>9. Large file, sequential write</td><td>NL . Lnet</td><td>NL . Lnet</td><td>1</td></tr><tr><td>10. Large file, sequential overwrite</td><td>NL . Lnet</td><td>2 . NL . Lnet</td><td>2</td></tr><tr><td>11. Large file, single write</td><td>Lnet</td><td>2 . NL : Lnet</td><td>2 : NL</td></tr></table></body></html>  

