[
    {
        "type": "text",
        "text": "4.6 Summary ",
        "text_level": 1,
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "We have introduced the most basic abstraction of the OS: the process. It is quite simply viewed as a running program. With this conceptual view in mind, we will now move on to the nitty-gritty: the low-level mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU. ",
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "ASIDE: KEY PROCESS TERMS ",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "• The process is the major OS abstraction of a running program. At any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers (including the program counter and stack pointer, among others), and information about I/O (such as open files which can be read or written).   \n• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.   \n• Processes exist in one of many different process states, including running, ready to run, and blocked. Different events (e.g., getting scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.   \n• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process control block (PCB), which is really just a structure that contains information about a specific process. ",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "OPERATINGSYSTEMS[VERSION 1.10]",
        "page_idx": 9
    }
]