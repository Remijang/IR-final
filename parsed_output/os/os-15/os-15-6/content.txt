15.6 Summary
In this chapter, we have extended the concept of limited direct execution with a specific mechanism used in virtual memory, known as address translation. With address translation, the OS can control each and every memory access from a process, ensuring the accesses stay within the bounds of the address space. Key to the efficiency of this technique is hardware support, which performs the translation quickly for each access, turning virtual addresses (the processâ€™s view of memory) into physical ones (the actual view). All of this is performed in a way that is transparent to the process that has been relocated; the process has no idea its memory references are being translated, making for a wonderful illusion.  
We have also seen one particular form of virtualization, known as base and bounds or dynamic relocation. Base-and-bounds virtualization is quite efficient, as only a little more hardware logic is required to add a  
OS @ run (kernel mode) To start process A: allocate entryHardwareProgram (user mode)in process table alloc memory for process set base/bound registers return-from-trap (into A)restore registers of A move to user mode jump to A's (initial) PCtranslate virtual address perform fetch if explicit load/store:Process A runs Fetch instruction Execute instructionHandle timer decide: stop A, run B call switch() routineensure address is legal translate virtual address perform load/store Timer interrupt move to kernel mode(A runs...)save regs(A) to proc-struct(A) (including base/bounds)jump to handlerrestore regs(B) from proc-struct(B)(including base/bounds)return-from-trap (into B)restore registers of Bmove to user mode jump to B's PCProcess B runsExecute bad loadLoad is out-of-bounds;move to kernel mode jump to trap handlerHandle the trapdecide to kill process Bdeallocate B's memoryfree B's entryin process tablemic Relocation) @ Runtim.
OPERATINGSYSTEMS[VERSION 1.10]  
WWW.OSTEP.ORG  
base register to the virtual address and check that the address generated by the process is in bounds. Base-and-bounds also offers protection; the OS and hardware combine to ensure no process can generate memory references outside its own address space. Protection is certainly one of the most important goals of the OS; without it, the OS could not control the machine (if processes were free to overwrite memory, they could easily do nasty things like overwrite the trap table and take over the system).  
Unfortunately, this simple technique of dynamic relocation does have its inefficiencies. For example, as you can see in Figure 15.2 (page 5), the relocated process is using physical memory from $\bar { 3 } 2 \ \mathrm { K B }$ to $\bar { 4 8 } \bar { \mathsf { K B } }$ ; however, because the process stack and heap are not too big, all of the space between the two is simply wasted. This type of waste is usually called internal fragmentation, as the space inside the allocated unit is not all used (i.e., is fragmented) and thus wasted. In our current approach, although there might be enough physical memory for more processes, we are currently restricted to placing an address space in a fixed-sized slot and thus internal fragmentation can arise2. Thus, we are going to need more sophisticated machinery, to try to better utilize physical memory and avoid internal fragmentation. Our first attempt will be a slight generalization of base and bounds known as segmentation, which we will discuss next.  