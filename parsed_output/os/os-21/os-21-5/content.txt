21.5 Page Fault Control Flow
With all of this knowledge in place, we can now roughly sketch the complete control flow of memory access. In other words, when somebody asks you “what happens when a program fetches some data from memory?”, you should have a pretty good idea of all the different possibilities. See the control flow in Figures 21.2 and 21.3 for more details; the first figure shows what the hardware does during translation, and the second what the OS does upon a page fault.  
From the hardware control flow diagram in Figure 21.2, notice that there are now three important cases to understand when a TLB miss occurs. First, that the page was both present and valid (Lines 18–21); in this case, the TLB miss handler can simply grab the PFN from the PTE, retry the instruction (this time resulting in a TLB hit), and thus continue as described (many times) before. In the second case (Lines 22–23), the page fault handler must be run; although this was a legitimate page for  
OPERATINGSYSTEMS[VERSION 1.10]  
1 PFN $\mathbf { \Sigma } = \mathbf { \Sigma }$ FindFreePhysicalPage() 
2 if $\begin{array} { r } { \left( \mathrm { P F N } \ \right. = \ - 1 ; } \end{array}$ ) // no free page found 
3 PFN $\mathbf { \Sigma } = \mathbf { \Sigma }$ EvictPage() // replacement algorithm 
4 DiskRead(PTE.DiskAddr, PFN) // sleep (wait for I/O) 
5 PTE.present $\mathbf { \Sigma } = \mathbf { \Sigma }$ True // update page table: 
6 PTE.PFN $\mathbf { \Sigma } = \mathbf { \Sigma }$ PFN // (present/translation) 
7 RetryInstruction() // retry instruction  
the process to access (it is valid, after all), it is not present in physical memory. Third (and finally), the access could be to an invalid page, due for example to a bug in the program (Lines 13–14). In this case, no other bits in the PTE really matter; the hardware traps this invalid access, and the OS trap handler runs, likely terminating the offending process.  
From the software control flow in Figure 21.3, we can see what the OS roughly must do in order to service the page fault. First, the OS must find a physical frame for the soon-to-be-faulted-in page to reside within; if there is no such page, we’ll have to wait for the replacement algorithm to run and kick some pages out of memory, thus freeing them for use here. With a physical frame in hand, the handler then issues the $\mathrm { I } / \mathrm { O }$ request to read in the page from swap space. Finally, when that slow operation completes, the OS updates the page table and retries the instruction. The retry will result in a TLB miss, and then, upon another retry, a TLB hit, at which point the hardware will be able to access the desired item.  