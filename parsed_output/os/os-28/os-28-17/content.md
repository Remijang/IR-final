# 28.17 Summary  

The above approach shows how real locks are built these days: some hardware support (in the form of a more powerful instruction) plus some operating system support (e.g., in the form of park() and unpark() primitives on Solaris, or futex on Linux). Of course, the details differ, and the exact code to perform such locking is usually highly tuned. Check out the Solaris or Linux code bases if you want to see more details; they are a fascinating read [L09, S09]. Also see David et al.’s excellent work for a comparison of locking strategies on modern multiprocessors $\scriptstyle [ { \mathrm { D } } + 1 3 ]$ .  

#  

References   
[D91] “Just Win, Baby: Al Davis and His Raiders” by Glenn Dickey. Harcourt, 1991. The book about Al Davis and his famous quote. Or, we suppose, the book is more about Al Davis and the Raiders, and not so much the quote. To be clear: we are not recommending this book, we just needed a citation. $[ \mathrm { D } \substack { + } 1 3 ]$ ] “Everything You Always Wanted to Know about Synchronization but Were Afraid to Ask” by Tudor David, Rachid Guerraoui, Vasileios Trigonakis. SOSP ’13, Nemacolin Woodlands Resort, Pennsylvania, November 2013. An excellent paper comparing many different ways to build locks using hardware primitives. Great to see how many ideas work on modern hardware. [D68] “Cooperating sequential processes” by Edsger W. Dijkstra. 1968. Available online here: http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD123.PDF. One of the early seminal papers. Discusses how Dijkstra posed the original concurrency problem, and Dekker’s solution. [H93] “MIPS R4000 Microprocessor User’s Manual” by Joe Heinrich. Prentice-Hall, June 1993. Available: http://cag.csail.mit.edu/raw/documents/R4400 Uman book Ed2.pdf. The old MIPS user’s manual. Download it while it still exists.   
[H91] “Wait-free Synchronization” by Maurice Herlihy. ACM TOPLAS, Volume 13: 1, January 1991. A landmark paper introducing a different approach to building concurrent data structures. Because of the complexity involved, some of these ideas have been slow to gain acceptance in deployment. [L81] “Observations on the Development of an Operating System” by Hugh Lauer. SOSP ’81, Pacific Grove, California, December 1981. A must-read retrospective about the development of the Pilot OS, an early PC operating system. Fun and full of insights.   
[L09] “glibc 2.9 (include Linux pthreads implementation)” by Many authors.. Available here: http://ftp.gnu.org/gnu/glibc. In particular, take a look at the nptl subdirectory where you will find most of the pthread support in Linux today.   
[M82] “The Architecture of the Burroughs B5000: 20 Years Later and Still Ahead of the Times?” by A. Mayer. 1982. Available: www.ajwm.net/amayer/papers/B5000.html. “It (RDLK) is an indivisible operation which reads from and writes into a memory location.” RDLK is thus testand-set! Dave Dahm created spin locks (“Buzz Locks”) and a two-phase lock called “Dahm Locks.” [M15] “OSSpinLock Is Unsafe” by J. McCall. mjtsai.com/blog/2015/12/16/osspinlock -is-unsafe. Calling OSSpinLock on a Mac is unsafe when using threads of different priorities – you might spin forever! So be careful, Mac fanatics, even your mighty system can be less than perfect... [MS91] “Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors” by John M. Mellor-Crummey and M. L. Scott. ACM TOCS, Volume 9, Issue 1, February 1991. An excellent and thorough survey on different locking algorithms. However, no operating systems support is used, just fancy hardware instructions.   
[P81] “Myths About the Mutual Exclusion Problem” by G.L. Peterson. Information Processing Letters, 12(3), pages 115–116, 1981. Peterson’s algorithm introduced here.   
[R97] “What Really Happened on Mars?” by Glenn E. Reeves. Available on our site at: https://www.ostep.org/Citations/mars.html. A description of priority inversion on Mars Pathfinder. Concurrent code correctness matters, especially in space!   
[S05] “Guide to porting from Solaris to Linux on $\mathbf { \Delta } \times 8 6 ^ { \prime \prime }$ by Ajay Sood, April 29, 2005. Available: http://www.ibm.com/developerworks/linux/library/l-solar/.   
[S09] “OpenSolaris Thread Library” by Sun.. Code: src.opensolaris.org/source/xref/ onnv/onnv-gate/usr/src/lib/libc/port/threads/synch.c. Pretty interesting, although who knows what will happen now that Oracle owns Sun. Thanks to Mike Swift for the pointer. [W09] “Load-Link, Store-Conditional” by Many authors.. en.wikipedia.org/wiki/LoadLink/Store-Conditional. Can you believe we referenced Wikipedia? But, we found the information there and it felt wrong not to. Further, it was useful, listing the instructions for the different architectures: ldl l/stl c and ldq l/stq c (Alpha), lwarx/stwcx (PowerPC), ll/sc (MIPS), and ldrex/strex (ARM). Actually Wikipedia is pretty amazing, so don’t be so harsh, OK? [WG00] “The SPARC Architecture Manual: Version $9 ^ { \prime \prime }$ by D. Weaver, T. Germond. SPARC International, 2000. http://www.sparc.org/standards/SPARCV9.pdf. See the website: developers.sun.com/solaris/articles/atomic sparc/ for more on atomics.  

# Homework (Simulation)  

This program, $\tt { x 8 6 . p y }$ , allows you to see how different thread interleavings either cause or avoid race conditions. See the README for details on how the program works and answer the questions below.  

# Questions  

1. Examine flag.s. This code “implements” locking with a single memory flag. Can you understand the assembly?   
2. When you run with the defaults, does flag.s work? Use the $- \mathbb { M }$ and $- \mathrm { R }$ flags to trace variables and registers (and turn on $- \mathtt { C }$ to see their values). Can you predict what value will end up in flag?   
3. Change the value of the register %bx with the -a flag (e.g., -a bx $: = 2$ , $\mathrm { b x } = 2$ if you are running just two threads). What does the code do? How does it change your answer for the question above?   
4. Set bx to a high value for each thread, and then use the $- \mathrm { i }$ flag to generate different interrupt frequencies; what values lead to a bad outcomes? Which lead to good outcomes?   
5. Now let’s look at the program test-and-set.s. First, try to understand the code, which uses the xchg instruction to build a simple locking primitive. How is the lock acquire written? How about lock release?   
6. Now run the code, changing the value of the interrupt interval $( - \mathrm { i } )$ again, and making sure to loop for a number of times. Does the code always work as expected? Does it sometimes lead to an inefficient use of the CPU? How could you quantify that?   
7. Use the $- \mathtt { P }$ flag to generate specific tests of the locking code. For example, run a schedule that grabs the lock in the first thread, but then tries to acquire it in the second. Does the right thing happen? What else should you test?   
8. Now let’s look at the code in peterson.s, which implements Peterson’s algorithm (mentioned in a sidebar in the text). Study the code and see if you can make sense of it.   
9. Now run the code with different values of -i. What kinds of different behavior do you see? Make sure to set the thread IDs appropriately (using $- a$ $\mathtt { b x } = 0$ , $\mathtt { b x } = 1$ for example) as the code assumes it.   
10. Can you control the scheduling (with the $- \mathtt { P }$ flag) to “prove” that the code works? What are the different cases you should show hold? Think about mutual exclusion and deadlock avoidance.   
11. Now study the code for the ticket lock in ticket.s. Does it match the code in the chapter? Then run with the following flags: $- a$ $\mathtt { b x } { = } 1 0 0 0$ , $\mathtt { b x } { = } 1 0 0 0$ (causing each thread to loop through the critical section 1000 times). Watch what happens; do the threads spend much time spin-waiting for the lock?   
12. How does the code behave as you add more threads?   
13. Now examine yield.s, in which a yield instruction enables one thread to yield control of the CPU (realistically, this would be an OS primitive, but for the simplicity, we assume an instruction does the task). Find a scenario where test-and-set.s wastes cycles spinning, but yield.s does not. How many instructions are saved? In what scenarios do these savings arise?   
14. Finally, examine test-and-test-and-set.s. What does this lock do? What kind of savings does it introduce as compared to test-and-set.s?  

OPERATINGSYSTEMS[VERSION 1.10]  