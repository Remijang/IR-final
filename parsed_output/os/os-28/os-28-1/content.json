[
    {
        "type": "text",
        "text": "28.1 Locks: The Basic Idea 333 ",
        "text_level": 1,
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "28.2 Pthread Locks . . 334   \n28.3 Building A Lock . 335   \n28.4 Evaluating Locks . 335   \n28.5 Controlling Interrupts . 336   \n28.6 A Failed Attempt: Just Using Loads/Stores . 337   \n28.7 Building Working Spin Locks with Test-And-Set . 338   \n28.8 Evaluating Spin Locks . . 341   \n28.9 Compare-And-Swap . . 342   \n28.10 Load-Linked and Store-Conditional . 343   \n28.11 Fetch-And-Add . . 344   \n28.12 Too Much Spinning: What Now? . 345   \n28.13 A Simple Approach: Just Yield, Baby . 346   \n28.14 Using Queues: Sleeping Instead Of Spinning . 347   \n28.15 Different OS, Different Support . . 350   \n28.16 Two-Phase Locks . . 352   \n28.17 Summary . 352   \nReferences . 353 ",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "OPERATINGSYSTEMS[VERSION 1.10]",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "Homework (Simulation) 354 ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "29 Lock-based Concurrent Data Structures 355 ",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "29.1 Concurrent Counters . 355   \n29.2 Concurrent Linked Lists . 361   \n29.3 Concurrent Queues . . 364   \n29.4 Concurrent Hash Table . 366   \n29.5 Summary . 366   \nReferences . 369   \nHomework (Code) . . 370 ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "30 Condition Variables 371 ",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "30.1 Definition and Routines . 372   \n30.2 The Producer/Consumer (Bounded Buffer) Problem . 376   \n30.3 Covering Conditions . . 384   \n30.4 Summary . 386   \nReferences . 387   \nHomework (Code) . . 388 ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "31 Semaphores 391",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "31.1 Semaphores: A Definition . 391   \n31.2 Binary Semaphores (Locks) . 393   \n31.3 Semaphores For Ordering . 394   \n31.4 The Producer/Consumer (Bounded Buffer) Problem . 396   \n31.5 Reader-Writer Locks . . 401   \n31.6 The Dining Philosophers . 403   \n31.7 Thread Throttling . . 406   \n31.8 How To Implement Semaphores . 406   \n31.9 Summary . 407   \nReferences . 409   \nHomework (Code) . . 410 ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "32 Common Concurrency Problems 411 ",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "32.1 What Types Of Bugs Exist? . 411   \n32.2 Non-Deadlock Bugs . 412   \n32.3 Deadlock Bugs . 415   \n32.4 Summary . 424   \nReferences . 425   \nHomework (Code) . . 426 ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "33 Event-based Concurrency (Advanced) 427 ",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "33.1 The Basic Idea: An Event Loop 427   \n33.2 An Important API: select() (or poll()) . 428   \n33.3 Using select() . . 429   \n33.4 Why Simpler? No Locks Needed . 431   \n33.5 A Problem: Blocking System Calls . 431   \n33.6 A Solution: Asynchronous I/O . . 432 ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "THREE EASY PIECES ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "33.7 Another Problem: State Management 433   \n33.8 What Is Still Difficult With Events . 435   \n33.9 Summary . 436   \nReferences . 437   \nHomework (Code) . . 438 ",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "34 Summary Dialogue on Concurrency 439 ",
        "text_level": 1,
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "III Persistence 441 ",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "35 A Dialogue on Persistence 443 ",
        "text_level": 1,
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "36 I/O Devices 445 ",
        "text_level": 1,
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "36.1 System Architecture 445   \n36.2 A Canonical Device 447   \n36.3 The Canonical Protocol 448   \n36.4 Lowering CPU Overhead With Interrupts 449   \n36.5 More Efficient Data Movement With DMA 450   \n36.6 Methods Of Device Interaction 451   \n36.7 Fitting Into The OS: The Device Driver . 452   \n36.8 Case Study: A Simple IDE Disk Driver . 453   \n36.9 Historical Notes 455   \n36.10 Summary 457   \nReferences 458 ",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "37 Hard Disk Drives 459 ",
        "text_level": 1,
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "37.1 The Interface 459   \n37.2 Basic Geometry 460   \n37.3 A Simple Disk Drive . 461   \n37.4 I/O Time: Doing The Math . 464   \n37.5 Disk Scheduling . 468   \n37.6 Summary . 472   \nReferences . 473   \nHomework (Simulation) . 474 ",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "38 Redundant Arrays of Inexpensive Disks (RAIDs) 475 ",
        "text_level": 1,
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "38.1 Interface And RAID Internals 476   \n38.2 Fault Model . 477   \n38.3 How To Evaluate A RAID . 477   \n38.4 RAID Level 0: Striping . . 478   \n38.5 RAID Level 1: Mirroring . 481   \n38.6 RAID Level 4: Saving Space With Parity . 484   \n38.7 RAID Level 5: Rotating Parity . 488   \n38.8 RAID Comparison: A Summary 489   \n38.9 Other Interesting RAID Issues . 490   \n38.10 Summary . 490 ",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "OPERATINGSYSTEMS[VERSION 1.10]",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "References 491   \nHomework (Simulation) . 492 ",
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "39 Interlude: Files and Directories 493 ",
        "text_level": 1,
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "39.1 Files And Directories . 493   \n39.2 The File System Interface 495   \n39.3 Creating Files . 495   \n39.4 Reading And Writing Files 497   \n39.5 Reading And Writing, But Not Sequentially 499   \n39.6 Shared File Table Entries: fork() And dup() . 501   \n39.7 Writing Immediately With fsync() . 504   \n39.8 Renaming Files . 504   \n39.9 Getting Information About Files . 506   \n39.10 Removing Files . 507   \n39.11 Making Directories . 508   \n39.12 Reading Directories . 509   \n39.13 Deleting Directories . 510   \n39.14 Hard Links . 510   \n39.15 Symbolic Links . 512   \n39.16 Permission Bits And Access Control Lists . 514   \n39.17 Making And Mounting A File System . 516   \n39.18 Summary . 518   \nReferences . 520   \nHomework (Code) . . 521 ",
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "40 File System Implementation 523 ",
        "text_level": 1,
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "40.1 The Way To Think 523   \n40.2 Overall Organization . 524   \n40.3 File Organization: The Inode 526   \n40.4 Directory Organization . 530   \n40.5 Free Space Management . . 532   \n40.6 Access Paths: Reading and Writing . 532   \n40.7 Caching and Buffering . . 536   \n40.8 Summary . 538   \nReferences . 539   \nHomework (Simulation) . 540 ",
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "41 Locality and The Fast File System 541 ",
        "text_level": 1,
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "41.1 The Problem: Poor Performance 541   \n41.2 FFS: Disk Awareness Is The Solution . 543   \n41.3 Organizing Structure: The Cylinder Group . 543   \n41.4 Policies: How To Allocate Files and Directories . 545   \n41.5 Measuring File Locality . 547   \n41.6 The Large-File Exception . 548   \n41.7 A Few Other Things About FFS . 550   \n41.8 Summary . 552   \nReferences . 553 ",
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "Homework (Simulation) 554 ",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "42 Crash Consistency: FSCK and Journaling 555 ",
        "text_level": 1,
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "42.1 A Detailed Example 556   \n42.2 Solution #1: The File System Checker . 559   \n42.3 Solution #2: Journaling (or Write-Ahead Logging) . 561   \n42.4 Solution #3: Other Approaches . 571   \n42.5 Summary . 572   \nReferences . 573   \nHomework (Simulation) . 575 ",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "43 Log-structured File Systems 577 ",
        "text_level": 1,
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "43.1 Writing To Disk Sequentially 578   \n43.2 Writing Sequentially And Effectively 579   \n43.3 How Much To Buffer? 580   \n43.4 Problem: Finding Inodes 581   \n43.5 Solution Through Indirection: The Inode Map 581   \n43.6 Completing The Solution: The Checkpoint Region 583   \n43.7 Reading A File From Disk: A Recap 583   \n43.8 What About Directories? 584   \n43.9 A New Problem: Garbage Collection . 585   \n43.10 Determining Block Liveness . 586   \n43.11 A Policy Question: Which Blocks To Clean, And When? . . 587   \n43.12 Crash Recovery And The Log . 588   \n43.13 Summary . 588   \nReferences . 590   \nHomework (Simulation) . 591 ",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "44 Flash-based SSDs 593 ",
        "text_level": 1,
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "44.1 Storing a Single Bit . 593   \n44.2 From Bits to Banks/Planes . 594   \n44.3 Basic Flash Operations . 595   \n44.4 Flash Performance And Reliability . 597   \n44.5 From Raw Flash to Flash-Based SSDs . 598   \n44.6 FTL Organization: A Bad Approach . 599   \n44.7 A Log-Structured FTL . . 600   \n44.8 Garbage Collection . . 602   \n44.9 Mapping Table Size . 604   \n44.10 Wear Leveling . 609   \n44.11 SSD Performance And Cost . 609   \n44.12 Summary . 611   \nReferences . 613   \nHomework (Simulation) . 615 ",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "45 Data Integrity and Protection 617 ",
        "text_level": 1,
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "45.1 Disk Failure Modes . 617   \n45.2 Handling Latent Sector Errors . 619 ",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "OPERATINGSYSTEMS[VERSION 1.10]",
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "45.3 Detecting Corruption: The Checksum 620   \n45.4 Using Checksums 623   \n45.5 A New Problem: Misdirected Writes . 624   \n45.6 One Last Problem: Lost Writes . 625   \n45.7 Scrubbing . 625   \n45.8 Overheads Of Checksumming 626   \n45.9 Summary . 627   \nReferences . 628   \nHomework (Simulation) . 629   \nHomework (Code) . . 630 ",
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "46 Summary Dialogue on Persistence 631 ",
        "text_level": 1,
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "47 A Dialogue on Distribution 633 ",
        "text_level": 1,
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "48 Distributed Systems 635 ",
        "text_level": 1,
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "48.1 Communication Basics . 636   \n48.2 Unreliable Communication Layers . 637   \n48.3 Reliable Communication Layers . 639   \n48.4 Communication Abstractions . 642   \n48.5 Remote Procedure Call (RPC) . 643   \n48.6 Summary . 648   \nReferences . 649   \nHomework (Code) . . 650 ",
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "49 Sunâ€™s Network File System (NFS) 653 ",
        "text_level": 1,
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "49.1 A Basic Distributed File System . 654   \n49.2 On To NFS . 655   \n49.3 Focus: Simple And Fast Server Crash Recovery . 655   \n49.4 Key To Fast Crash Recovery: Statelessness . 656   \n49.5 The NFSv2 Protocol . 657   \n49.6 From Protocol To Distributed File System . 659   \n49.7 Handling Server Failure With Idempotent Operations . 661   \n49.8 Improving Performance: Client-side Caching . 663   \n49.9 The Cache Consistency Problem . 663   \n49.10 Assessing NFS Cache Consistency . 665   \n49.11 Implications On Server-Side Write Buffering . 665   \n49.12 Summary . 667   \nReferences . 669   \nHomework (Measurement) . . 670 ",
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "50 The Andrew File System (AFS) 671 ",
        "text_level": 1,
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "50.1 AFS Version 1 . 671   \n50.2 Problems with Version 1 . 673   \n50.3 Improving the Protocol . 674   \n50.4 AFS Version 2 . . 674   \n50.5 Cache Consistency . 676 ",
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "THREE EASY PIECES ",
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "50.6 Crash Recovery 678   \n50.7 Scale And Performance Of AFSv2 679   \n50.8 AFS: Other Improvements . . 681   \n50.9 Summary . 682   \nReferences . 683   \nHomework (Simulation) . 684 ",
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "51 Summary Dialogue on Distribution 685 ",
        "text_level": 1,
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "General Index 687 ",
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "Asides 699 ",
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "Tips 703 ",
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "Cruces 707 ",
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "OPERATINGSYSTEMS[VERSION 1.10]",
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "WWW.OSTEP.ORG ",
        "page_idx": 11
    }
]