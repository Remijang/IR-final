26.4 The Heart Of The Problem: Uncontrolled Scheduling
To understand why this happens, we must understand the code sequence that the compiler generates for the update to counter. In this case, we wish to simply add a number (1) to counter. Thus, the code sequence for doing so might look something like this (in x86);  
mov 0x8049a1c, %eax add $\$ 0 x1$ , %eax mov %eax, 0x8049a1c  
This example assumes that the variable counter is located at address $0 \times 8 0 4 9 \mathrm { a } 1 \mathrm { c }$ . In this three-instruction sequence, the $\boldsymbol { \times } 8 6 \mathrm { ~ m o v ~ }$ instruction is used first to get the memory value at the address and put it into register eax. Then, the add is performed, adding 1 (0x1) to the contents of the eax register, and finally, the contents of eax are stored back into memory at the same address.  
Let us imagine one of our two threads (Thread 1) enters this region of code, and is thus about to increment counter by one. It loads the value of counter (let’s say it’s 50 to begin with) into its register eax. Thus, $\mathtt { e a x } = 5 0$ for Thread 1. Then it adds one to the register; thus $\mathtt { e a x } = 5 1$ . Now, something unfortunate happens: a timer interrupt goes off; thus, the OS saves the state of the currently running thread (its ${ \bar { \mathrm { P C } } } ,$ its registers including eax, etc.) to the thread’s TCB.  
Now something worse happens: Thread 2 is chosen to run, and it enters this same piece of code. It also executes the first instruction, getting the value of counter and putting it into its eax (remember: each thread when running has its own private registers; the registers are virtualized by the context-switch code that saves and restores them). The value of counter is still 50 at this point, and thus Thread 2 has $\mathtt { e a x } = 5 0$ . Let’s then assume that Thread 2 executes the next two instructions, incrementing eax by 1 (thus $\mathtt { e a x } = 5 1$ ), and then saving the contents of eax into counter (address $0 { \times } 8 0 4 9 { \mathrm { a } } 1 { \mathrm { c } }$ ). Thus, the global variable counter now has the value 51.  
Finally, another context switch occurs, and Thread 1 resumes running. Recall that it had just executed the mov and add, and is now about to perform the final mov instruction. Recall also that $\mathtt { e a x } = 5 1$ . Thus, the final mov instruction executes, and saves the value to memory; the counter is set to 51 again.  
Put simply, what has happened is this: the code to increment counter has been run twice, but counter, which started at 50, is now only equal to 51. A “correct” version of this program should have resulted in the variable counter equal to 52.  
Let’s look at a detailed execution trace to understand the problem better. Assume, for this example, that the above code is loaded at address 100 in memory, like the following sequence (note for those of you used to nice, RISC-like instruction sets: $\bar { \bf x } 8 6$ has variable-length instructions; this mov instruction takes up 5 bytes of memory, and the add only 3):  
osThread 1Thread 2.PC(after instruction)eax counterbefore critical section100050mov 8049a1c,%eax105 5050add $0xl,%eax1085150interrupt save T1restore T2100050mov 8049a1c,%eax105 5050add $0x1,%eax1085150mov %eax,8049a1c1135151interruptsave T2restore T11085151mov %eax,8049a1c1135151
100 mov 0x8049a1c, %eax 
105 add $\$ 0 x1$ , %eax 
108 mov %eax, 0x8049a1c  
With these assumptions, what happens is shown in Figure 26.7 (page 10). Assume the counter starts at value 50, and trace through this example to make sure you understand what is going on.  
What we have demonstrated here is called a race condition (or, more specifically, a data race): the results depend on the timing of the code’s execution. With some bad luck (i.e., context switches that occur at untimely points in the execution), we get the wrong result. In fact, we may get a different result each time; thus, instead of a nice deterministic computation (which we are used to from computers), we call this result indeterminate, where it is not known what the output will be and it is indeed likely to be different across runs.  
Because multiple threads executing this code can result in a race condition, we call this code a critical section. A critical section is a piece of code that accesses a shared variable (or more generally, a shared resource) and must not be concurrently executed by more than one thread.  
What we really want for this code is what we call mutual exclusion. This property guarantees that if one thread is executing within the critical section, the others will be prevented from doing so.  
Virtually all of these terms, by the way, were coined by Edsger Dijkstra, who was a pioneer in the field and indeed won the Turing Award because of this and other work; see his 1968 paper on “Cooperating Sequential Processes” [D68] for an amazingly clear description of the problem. We’ll be hearing more about Dijkstra in this section of the book.  
OPERATINGSYSTEMS[VERSION 1.10]  
TIP: USE ATOMIC OPERATIONS
Atomic operations are one of the most powerful underlying techniques in building computer systems, from the computer architecture, to concurrent code (what we are studying here), to file systems (which we’ll study soon enough), database management systems, and even distributed systems $[ { \mathrm { L } } + 9 3 ]$ .  
The idea behind making a series of actions atomic is simply expressed with the phrase “all or nothing”; it should either appear as if all of the actions you wish to group together occurred, or that none of them occurred, with no in-between state visible. Sometimes, the grouping of many actions into a single atomic action is called a transaction, an idea developed in great detail in the world of databases and transaction processing [GR92].  
In our theme of exploring concurrency, we’ll be using synchronization primitives to turn short sequences of instructions into atomic blocks of execution, but the idea of atomicity is much bigger than that, as we will see. For example, file systems use techniques such as journaling or copyon-write in order to atomically transition their on-disk state, critical for operating correctly in the face of system failures. If that doesn’t make sense, don’t worry — it will, in some future chapter.  