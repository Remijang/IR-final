# 54.7 Authenticating Non-Humans  

No, we’re not talking about aliens or extra-dimensional beings, or even your cat. If you think broadly about how computers are used today, you’ll see that there are many circumstances in which no human user is associated with a process that’s running. Consider a web server. There really isn’t some human user logged in whose identity should be attached to the web server. Or think about embedded devices, such as a smart light bulb. Nobody logs in to a light bulb, but there is certainly code running there, and quite likely it is process-oriented code.  

Mechanically, the operating system need not have a problem with the identities of such processes. Simply set up a user called webserver or lightbulb on the system in question and attach the identity of that “user” to the processes that are associated with running the web server or turning the light bulb on and off. But that does lead to the question of how you make sure that only real web server processes are tagged with that identity. We wouldn’t want some arbitrary user on the web server machine creating processes that appear to belong to the server, rather than to that user.  

One approach is to use passwords for these non-human users, as well. Simply assign a password to the web server user. When does it get used? When it’s needed, which is when you want to create a process belonging to the web server, but you don’t already have one in existence. The system administrator could log in as the web server user, creating a command shell and using it to generate the actual processes the server needs to do its business. As usual, the processes created by this shell process would inherit their parent’s identity, webserver, in this case. More commonly, we skip the go-between (here, the login) and provide some mechanism whereby the privileged user is permitted to create processes that belongs not to that user, but to some other user such as webserver. Alternately, we can provide a mechanism that allows a process to change its ownership, so the web server processes would start off under some other user’s identity (such as the system administrator’s) and change their ownership to webserver. Yet another approach is to allow a temporary change of process identity, while still remembering the original identity. (We’ll say more about this last approach in a future chapter.) Obviously, any of these approaches require strong controls, since they allow one user to create processes belonging to another user.  

As mentioned above, passwords are the most common authentication method used to determine if a process can be assigned to one of these non-human users. Sometimes no authentication of the non-human user is required at all, though. Instead, certain other users (like trusted system administrators) are given the right to assign new identities to the processes they create, without providing any further authentication information than their own. In Linux and other Unix systems, the sudo command offers this capability. For example, if you type the following:  

sudo -u webserver apache2  

OPERATINGSYSTEMS[VERSION 1.10]  

# ASIDE: OTHER AUTHENTICATION POSSIBILITIES  

Usually, what you know, what you have, and what you are cover the useful authentication possibilities, but sometimes there are other options. Consider going into the Department of Motor Vehicles to apply for a driver’s license. You probably go up to a counter and talk to some employee behind that counter, perhaps giving the person a bunch of personal information, maybe even money to cover a fee for the license. Why on earth did you believe that person was actually a DMV employee who was able to get you a legitimate driver’s license? You probably didn’t know the person; you weren’t shown an official ID card; the person didn’t recite the secret DMV mantra that proved he or she was an initiate of that agency. You believed it because the person was standing behind a particular counter, which is the counter DMV employees stand behind. You authenticated the person based on location.  

Once in a while, that approach can be handy in computer systems, most frequently in mobile or pervasive computing. If you’re tempted to use it, think carefully about how you’re obtaining the evidence that the subject really is in a particular place. It’s actually fairly tricky.  

What else? Perhaps you can sometimes authenticate based on what someone does. If you’re looking for personally characteristic behavior, like their typing pattern or delays between commands, that’s a type of biometric. (Google introduced multi-factor authentication of this kind in its Android phones, for example.) But you might be less interested in authenticating exactly who they are versus authenticating that they belong to the set of Well Behaved Users. Many web sites, for example, care less about who their visitors are and more about whether they use the web site properly. In this case, you might authenticate their membership in the set by their ongoing interactions with your system.  

This would indicate that the apache2 program should be started under the identity of webserver, rather than under the identity of whoever ran the sudo command. This command might require the user running it to provide their own authentication credentials (for extra certainty that it really is the privileged user asking for it, and not some random visitor accessing the computer during the privileged user’s coffee break), but would not require authentication information associated with webserver Any sub-processes created by apache2 would, of course, inherit the identity of webserver. We’ll say more about sudo in the chapter on access control.  

One final identity issue we alluded to earlier is that sometimes we wish to identify not just individual users, but groups of users who share common characteristics, usually security-related characteristics. For example, we might have four or five system administrators, any one of whom is allowed to start up the web server. Instead of associating the privilege with each one individually, it’s advantageous to create a systemmeaningful group of users with that privilege. We would then indicate that the four or five administrators are members of that group. This kind of group is another example of a security-relevant principal, since we will make our decisions on the basis of group membership, rather than individual identity. When one of the system administrators wished to do something requiring group membership, we would check that he or she was a member. We can either associate a group membership with each process, or use the process’s individual identity information as an index into a list of groups that people belong to. The latter is more flexible, since it allows us to put each user into an arbitrary number of groups.  

Most modern operating systems, including Linux and Windows, support these kinds of groups, since they provide ease and flexibility in dealing with application of security policies. They handle group membership and group privileges in manners largely analogous to those for individuals. For example, a child process will usually have the same group-related privileges as its parent. When working with such systems, it’s important to remember that group membership provides a second path by which a user can obtain access to a resource, which has its benefits and its dangers.  

