B.5 CUDA Programs

A CUDA program naturally maps to the structure of a GPU. We first write a kernel in CUDA that performs a set of operations depending on the thread id that it is assigned at runtime. A dynamic instance of a kernel is a thread (similar to a thread in the context of a CPU). We group a set of threads into a block, or a CTA (co-operative thread array). A block or a CTA corresponds to a warp. We can have 1–512 threads in a block, and each SM can buffer the state of at most 8 blocks at any point of time. Each thread in a block has a unique thread id. Similarly, blocks are grouped together in a grid. The grid contains all the threads for an application. Different blocks (or warps) may execute independently of each other, unless we explicitly enforce some form of synchronization. In our simple example, we consider a block to be a linear array of threads, and a grid to be a linear array of blocks. Additionally, we can define a block to be a 2D or 3D array of threads, or a grid to be a 2D or 3D array of blocks.

Let us now look at a small CUDA program to add two  element arrays. Let us consider the CUDA program in parts. In the following code snippet, we initialize three arrays  ,  , and  . We wish to add  and  element wise and save the results in  .

In this code snippet we declare three arrays  , and  ) with  elements in Line 5. Subsequently, in Line 9, we define their corresponding storage locations (gpu a, gpu b and gpu c) in the GPU. We then allocate space for them in the GPU by using the cudaMalloc call. Next, we initialize arrays  and  with values (code not shown), and then copy these arrays to the corresponding locations (gpu a, and gpu b) in the GPU using the CUDA function cudaMemcpy. It uses a flag called cudaMemcpyHostT oDevice. In this case the host is the CPU and the device is the GPU.

The next operation is to add the vectors gpu a, and gpu b in the GPU. For this purpose, we need to write a vectorAdd function that can add the vectors. This function should take three arguments consisting of two input vectors, and an output vector. Let us for the time being assume that we have such a function with us. Let us show the code to invoke this function.

We invoke the vectorAdd function with three arguments: gpu a, gpu b and gpu c. Let us now look at the expression:  . This piece of code indicates to the GPU that we have  blocks, and each block contains 32 threads. Let us now assume that the GPU magically adds the two arrays and saves the results in the array gpu c in its physical memory space. The last step in the main function is to fetch the results from the GPU, and free space in the GPU. The code for it is as follows.

Now, let us define the function vectorAdd, which needs to be executed on the GPU.

/\* The GPU kernel \*/ __global__ void vectorAdd ( int \*gpu a, int \*gpu b, int \*gpu c) { 3 /\* compute the index \*/ 4 int idx  threadIdx.x  blockIdx.x  blockDim.x; 5 6 /\* perform the addition \*/ 7 gpu_c[idx]  gpu_a[idx] + gpu_b[idx]; 8

Here, we access some built in variables that are populated by the CUDA runtime. In general, a grid and a block have three axes (x, y, and z). Since we assume only one axis in the blocks and the grid in this example, we only use the x axis. The variable blockDim.x is equal to the number of threads in a block. If we had considered 2D grids, then the dimension of a block would have been  . blockIdx.  is the index of the block, and threadIdx.  is the index of the thread in the block. Thus, the expression  represents the index of the thread. Note that in this example, we associate each element of the arrays with a thread. Since the overhead of creation, initialization, and switching of threads is small, we can adopt this approach in the case of a GPU. In the case of a CPU that has large overheads with creating and managing threads, this approach is not feasible. Once, we compute the index of the thread, we perform the addition in Line 7.

The GPU creates  copies of this kernel, and distributes it among  threads. Each of the kernels computes a different index in Line 4, and proceeds to perform the addition in Line 7. We showed a simple example. However, it is possible to write extremely complicated programs using the CUDA extensions to C/C++ replete with synchronization statements, and conditional branch statements. The reader can consult the book by Farber [Farber, 2011] for an in-depth coverage of CUDA programming.

To summarize, let us show the entire GPU program. Note that we club the kernel of the GPU along with the code that is executed by the CPU into a single program. NVIDIA’s compiler splits the single file into two binaries. One binary runs on the CPU and uses the CPU’s instruction set, and the other binary runs on the GPU and uses the PTX instruction set. This is a classical example of a MPMD style of execution where we have different programs in different instruction sets, and multiple streams of data. Thus, we can think of the GPU’s parallel programming model as a combination of SIMD, MPMD, and fine grained multithreading at the level of warps. We leave the readers with an artist’s impression of a GPU (see Figure B.5).

10   
11 void main()   
12  Declare three arrays a, b, and c \*/   
13 int a[N], b[N], c[N];   
14   
15  Declare the corresponding arrays in the GPU \*/   
16 int size  N \* sizeof(int);   
17 int \*gpu_a, \*gpu_b, \*gpu_c;   
18   
19  allocate space for the arrays in the GPU \*/   
20 cudaMalloc((void\*\*) &gpu_a, size);   
21 cudaMalloc((void  ) &gpu_b, size);   
22 cudaMalloc((void\*\*) &gpu_c, size);   
23   
24  initialize arrays, a and b \*/   
25   
26   
27 /\* copy the arrays to the GPU    
28 cudaMemcpy (gpu_a, a, size, cudaMemcpyHostToDevice);   
29 cudaMemcpy (gpu_b, b, size, cudaMemcpyHostToDevice);   
30   
31 /\* invoke the vector add operation in the GPU \*/

Bibliography

[arm, a] The arm architecture with a focus on v7a and cortex-a8. www.arm.com/files/pdf/ ARM_Arch_A8.pdf. Online: accessed on  Nov, 2013.   
[arm, b] Arm cortex-m3 introduction. www.arm.com/files/pdf/CortexM3_Uni_Intro.pdf. Online: accessed on  Nov, 2013.   
[nic, ] Atm network interface. http://en.wikipedia.org/wiki/File:ForeRunnerLE_25_ ATM_Network_Interface_%281%29.jpg. Online: accessed on  October, 2013.   
[bak, ] Bakhshali manuscripl. http://en.wikipedia.org/wiki/Bakhshali_manuscript/. Online: accessed on  Nov, 2013.   
[dis, ] Compact disc. http://openclipart.org/detail/104191/ compact-disc-by-decosigner. Online: accessed on  October, 2013.   
[arm, c] Cortex -a15 mpcore tm tm revision: r3p2 technical reference manual. www.arm.com. Online: accessed on  Nov, 2013.   
[ccl, ] Creative commons share alike license 3.0. http://creativecommons.org/licenses/ by-sa/3.0/. Online: accessed on  October, 2013.   
[arm, d] Exploring the design of the cortex-a15 processor. www.arm.com/files/pdf/ at-exploring_the_design_of_the_cortex-a15.pdf. Online: accessed on  Nov, 2013.   
[gx8, ] Gnu x86 assembler. http://www.gnu.org. Online: accessed on  Nov, 2013.   
[har, ] Hard disc – open clipart. http://openclipart.org/detail/170369/ hard-disk-by-ilnanny-170369. Online: accessed on  October, 2013.   
[fir, ] Ieee 1394 standard. http://standards.ieee.org/findstds/standard/1394-1995. html. Online: accessed on  October, 2013.   
[int, ] Intel 64 and ia 32 architectures software developer manuals. http://www.intel.com/ content/www/us/en/processors/architectures-software-developer-manuals.html.   
[ind, ] Interesting facts about india – my india, my pride – national portal of india. http: //knowindia.gov.in/myindia/myindia_frame.php?id=10.   
[mas, ] Microsoft macro assembler 8.0 (masm) package. http://www.microsoft.com/en-in/ download/details.aspx?id  12654. Online: accessed on  Nov, 2013.   
[nas, ] The netwide assembler. http://www.nasm.us. Online: accessed on  Nov, 2013.

[pci, ] Pci express specifications. http://www.pcisig.com/specifications/pciexpress. Online: accessed on  October, 2013.   
[red, ] Red book (audio cd standard). http://www.princeton.edu/\~achaney/tmve/ wiki100k/docs/Red_Book_(audio_CD_standard).html.   
[ris, ] The risc-v instruction set manual volume i. www.riscv.org. Online: accessed on  May, 2024.   
[sat, ] Sata specifications. https://www.sata-io.org/technical-library. Online: accessed on  October, 2013.   
[uni, ] The unicode standard. http://www.unicode.org/standard/standard.html. Online: accessed on  Nov, 2013.   
[usb, ] Usb specification. http://www.usb.org/developers/docs/. Online: accessed on  October, 2013.   
[scs, ] Www virtual library for scsi. http://www.scsilibrary.com. Online: accessed on  October, 2013.   
[arm, 2000] (2000). ARM Architecture Reference Manual . ARM Limited.   
[Abramovitch, 2001] Abramovitch, D. (2001). Magnetic and optical disk control: parallels and contrasts. In American Control Conference, 2001. Proceedings of the 2001, volume 1, pages 421–428 vol.1.   
[Adve and Gharachorloo, 1996] Adve, S. V. and Gharachorloo, K. (1996). Shared memory consistency models: A tutorial. computer, 29(12):66–76.   
[Adve et al., 2003] Adve, V., Lattner, C., Brukman, M., Shukla, A., and Gaeke, B. (2003). Llva: a low-level virtual instruction set architecture. In Microarchitecture, 2003. MICRO-36. Proceedings. 36th Annual IEEE/ACM International Symposium on, pages 205 – 216.   
[Aho et al., 2006] Aho, A. V., Lam, M. S., Sethi, R., and Ullman, J. D. (2006). Compilers, Principles, Techniques, and Tools. Addison Wesley.   
[Akkary et al., 2003] Akkary, H., Rajwar, R., and Srinivasan, S. T. (2003). Checkpoint processing and recovery: Towards scalable large instruction window processors. In Microarchitecture, 2003. MICRO-36. Proceedings. 36th Annual IEEE/ACM International Symposium on, pages 423–434. IEEE.   
[Arvind and Maessen, 2006] Arvind, A. and Maessen, J.-W. (2006). Memory model= instruction reordering+ store atomicity. In ACM SIGARCH Computer Architecture News, volume 34, pages 29–40. IEEE Computer Society.   
[Asanovi´c and Patterson, 2014] Asanovic´, K. and Patterson, D. A. (2014). Instruction sets should be free: The case for risc-v. EECS Department, University of California, Berkeley, Tech. Rep. UCB/EECS-2014-146.   
[Austin et al., 2002] Austin, T., Larson, E., and Ernst, D. (2002). SimpleScalar: An infrastructure for computer system modeling. IEEE Computer, 35(2):59–67.   
[Baer, 2010] Baer, J.-L. (2010). Microprocessor Architecture: from simple pipelines to chip multiprocessors. Cambridge University Press.   
[Balasubramonian et al., 2011] Balasubramonian, R., Jouppi, N. P., and Muralimanohar, N. (2011). Multi-core cache hierarchies. Synthesis Lectures on Computer Architecture, 6(3):1– 153.   
[Bergstra and Middelburg, 2012] Bergstra, J. A. and Middelburg, C. A. (2012). Instruction Sequences for Computer Science . Atlantis.   
[Blythe, 2008] Blythe, D. (2008). Rise of the graphics processor. Proceedings of the IEEE, 96(5):761–778.   
[Boggs et al., 2004] Boggs, D., Baktha, A., Hawkins, J., Marr, D. T., Miller, J. A., Roussel, P., Singhal, R., Toll, B., and Venkatraman, K. (2004). The microarchitecture of the intel pentium 4 processor on 90nm technology. Intel Technology Journal, 8(1):1–17.   
[Borrill, 1987] Borrill, P. (1987). Ieee 896.1: the futurebus. Electronics and Power, 33(10):628– 631.   
[Bourgeat et al., 2021] Bourgeat, T., Clester, I., Erbsen, A., Gruetter, S., Wright, A., and Chlipala, A. (2021). A multipurpose formal risc-v specification. arXiv preprint arXiv:2104.00762.   
[Brent and Zimmermann, 2010] Brent, R. P. and Zimmermann, P. (2010). Modern Computer Arithmetic. Cambridge University Press.   
[Brewer and Gill, 2008] Brewer, J. and Gill, M. (2008). Nonvolatile Memory Technologies with Emphasis on Flash: A Comprehensive Guide to Understanding and Using Flash Memory Devices. IEEE Press Series on Microelectronic Systems (Book 8). Wiley-IEEE Press.   
[Brown et al., 2001] Brown, M. D., Stark, J., and Patt, Y. N. (2001). Select-free instruction scheduling logic. In Microarchitecture, 2001. MICRO-34. Proceedings. 34th ACM/IEEE International Symposium on, pages 204–213. IEEE.   
[Burgess et al., 2011] Burgess, B., Cohen, B., Denman, M., Dundas, J., Kaplan, D., and Rupley, J. (2011). Bobcat: Amd’s low-power x86 processor. Micro, IEEE, 31(2):16–25.   
[Butler et al., 2011] Butler, M., Barnes, L., Sarma, D. D., and Gelinas, B. (2011). Bulldozer: An approach to multithreaded compute performance. Micro, IEEE, 31(2):6–15.   
[Carpenter and Doran, 1986] Carpenter, B. E. and Doran, R. W. (1986). Turing’s ACE Report of 1946 and Other Papers. Technical report, Cambridge.   
[Carter, 1995] Carter, J. W. (1995). Microprocessor Architecture and Microprogramming: A State Machine Approach. Prentice Hall.   
[Cavanagh, 2013] Cavanagh, J. (2013). x86 Assembly Language and C Fundamentals. CRC Press.   
[Celio et al., 2017] Celio, C., Chiu, P.-F., Nikolic, B., Patterson, D. A., and Asanovic, K. (2017). Boomv2: an open-source out-of-order risc-v core. In First Workshop on Computer Architecture Research with RISC-V (CARRV).   
[Chen and Patterson, 2016] Chen, T. and Patterson, D. A. (2016). Risc-v geneology. EECS Department, University of California, Berkeley, Tech. Rep. UCB/EECS-2016-6.   
[Cheng and Hu, 1999] Cheng, Y. and Hu, C. (1999). MOSFET Modeling and Bsim3 User’s Guide. Kluwer Academic Publishers, Norwell, MA, USA.   
[Consortium et al., 2006] Consortium, H. T. et al. (2006). Hypertransport i/o link specification revision 3.00. Document# HTC20051222-0046-0008.   
[Conway and Hughes, 2007] Conway, P. and Hughes, B. (2007). The amd opteron north bridge architecture. Micro, IEEE, 27(2):10–21.   
[Cormen et al., 2009] Cormen, T. H., Leiserson, C. E., Rivest, R. L., and Stein, C. (2009). Introduction to Algorithms. MIT Press, third edition.   
[Cover and Thomas, 2013] Cover, T. M. and Thomas, J. A. (2013). Elements of Information Theory. Wiley.   
[Culler et al., 1998] Culler, D., Singh, J. P., and Gupta, A. (1998). Parallel Computer Architecture: A Hardware/Software Approach. The Morgan Kaufmann series in Computer Architecture Design. Morgan Kaufmann.   
[Dally and Poulton, 1998] Dally, W. J. and Poulton, J. W. (1998). Digital Systems Engineering. Cambridge University Press.   
[Danowitz et al., 2012] Danowitz, A., Kelley, K., Mao, J., Stevenson, J. P., and Horowitz, M. (2012). Cpu db: recording microprocessor history. Communications of the ACM, 55(4):55–63.   
[Das, 2010] Das, L. B. (2010). The X86 Microprocessors : Architecture and Programming (8086 to Pentium). Pearson.   
[Downing and Meyer, 1997] Downing, T. and Meyer, J. (1997). Java Virtual Machine. O’Reilly Media.   
[Durr et al., 2009] Durr, S., Fodor, Z., Frison, J., Hoelbling, C., Hoffmann, R., Katz, S. D., Krieg, S., Kurth, T., Lellouch, L., Lippert, T., Szabo, K. K., and Vulvert, G. (2009). Abinitio determination of light hadron masses.   
[Edler and Hill, 1999] Edler, J. and Hill, M. D. (1999). Dinero iv trace-driven uniprocessor cache simulator” http://www. cs. wisc. edu/markhill.   
[Elsner and Fenlason, 1994] Elsner, D. and Fenlason, J. (1994). Using as – The GNU Assembler.   
[Farber, 2011] Farber, R. (2011). CUDA Application Design and Development. Morgan Kaufmann.   
[Farquhar and Bunce, 2012] Farquhar, E. and Bunce, P. J. (2012). The MIPS Programmers Handbook . Morgan Kaufmann.   
[Frolov et al., 2021] Frolov, V. A., Galaktionov, V. A., and Sanzharov, V. V. (2021). Investigation of risc-v. Programming and Computer Software, 47:493–504.   
[Gharachorloo et al., 1992] Gharachorloo, K., Adve, S. V., Gupta, A., Hennessy, J. L., and Hill, M. D. (1992). Programming for different memory consistency models. Journal of parallel and distributed computing, 15(4):399–407.   
[Gibson, 2011] Gibson, J. R. (2011). ARM Assembly Language an Introduction. Lulu.   
[Gilreath and Laplante, 2003] Gilreath, W. F. and Laplante, P. A. (2003). Computer Architecture: A Minimalist Perspective. Springer.   
[gnu.org, ] gnu.org. Gnu binutils. http://www.gnu.org/software/binutils.   
[Greengard, 2020] Greengard, S. (2020). Will risc-v revolutionize computing? Communications of the ACM, 63(5):30–32.   
[Gregg, 1998] Gregg, J. (1998). Ones and zeros: understanding boolean algebra, digital circuits, and the logic of sets. Wiley-IEEE Press.   
[Guiady et al., 1999] Guiady, C., Falsafi, B., and Vijaykumar, T. N. (1999). Is sc+ ilp= rc? In Computer Architecture, 1999. Proceedings of the 26th International Symposium on, pages 162–171. IEEE.   
[Gwennap, 2010] Gwennap, L. (2010). Sandy bridge spans generations. Microprocessor Report, 9(27):10–01.   
[Halfhill, 2008] Halfhill, T. R. (2008). Intel’s tiny atom. Microprocessor Report, 22(4):1.   
[Hamacher et al., 2001] Hamacher, C., Vranesic, Z., and Zaky, S. (2001). Computer Organization. McGrawHill.   
[Hartstein et al., 2006] Hartstein, A., Srinivasan, V., Puzak, T. R., and Emma, P. G. (2006). Cache miss behavior: is it &#8730;2? In Proceedings of the 3rd conference on Computing frontiers, CF ’06, pages 313–320.   
[Henessey and Patterson, 2010] Henessey, J. and Patterson, D. (2010). Computer Organization and Design: The Hardware/Software Interface. Morgan Kaufmann.   
[Hennessy and Patterson, 2012] Hennessy, J. L. and Patterson, D. A. (2012). Computer architecture: a quantitative approach. Elsevier.   
[Hill et al., 1999] Hill, M. D., Jouppi, N. P., and Sohi, G. S. (1999). Readings in Computer Architecture. The Morgan Kaufmann series in Computer Architecture Design. Morgan Kaufmann.   
[Hohl, 2009] Hohl, W. (2009). ARM Assembly Language: Fundamentals and Techniques. CRC Press.   
[Hopcroft et al., 2006] Hopcroft, J. E., Motwani, R., and Ulmann, J. D. (2006). Introduction to Automata Theory, Languages, and Computation. Prentice Hall.   
[Hughes et al., 2013] Hughes, J. F., Dam, A. V., Mcguire, M., Sklar, D. F., Foley, J. D., Feiner, S. K., and Akeley, K. (2013). Computer Graphics: Principles and Practice. Addison Wesley.   
[Husson, 1970] Husson, S. S. (1970). Microprogramming: Principles and Practices. Prentice Hall.   
[Hwang, 2003] Hwang, K. (2003). Advanced computer architecture. Tata McGraw-Hill Education.   
[Hwu and Patt, 1987] Hwu, W.-M. W. and Patt, Y. N. (1987). Checkpoint repair for high-performance out-of-order execution machines. Computers, IEEE Transactions on, 100(12):1496–1514.   
[INTEL, 2010] INTEL, I. (2010). Intel r 64 and ia-32 architectures software developer’s manual.   
[ITRS, 2011] ITRS (2011). International Technology Roadmap for Semiconductors. http: //www.itrs.net/Links/2011ITRS/Home2011.htm.   
[Jacob, 2009] Jacob, B. (2009). The memory system: you can’t avoid it, you can’t ignore it, you can’t fake it. Synthesis Lectures on Computer Architecture, 4(1):1–77.   
[Jacob et al., 2007] Jacob, B., Ng, S., and Wang, D. (2007). Memory Systems: Cache, DRAM, Disk. Morgan Kaufmann.   
[Jerger and Peh, 2009] Jerger, N. E. and Peh, L.-S. (2009). On-chip networks. Synthesis Lectures on Computer Architecture, 4(1):1–141.   
[Kahan, 1996] Kahan, W. (1996). Ieee standard 754 for binary floating-point arithmetic. Lecture Notes on the Status of IEEE, 754.   
[Kanter, 2016] Kanter, D. (2016). Risc-v offers simple, modular isa. Microprocessor Report, 1:1–5.   
[Keleher et al., 1994] Keleher, P., Cox, A. L., Dwarkadas, S., and Zwaenepoel, W. (1994). Treadmarks: Distributed shared memory on standard workstations and operating systems. In USENIX Winter, volume 1994.   
[Keltcher et al., 2003] Keltcher, C. N., McGrath, K. J., Ahmed, A., and Conway, P. (2003). The amd opteron processor for multiprocessor servers. Micro, IEEE, 23(2):66–76.   
[Kohavi and Jha, 2009] Kohavi, Z. and Jha, N. K. (2009). Switching and Finite Automata Theory. Cambridge University Press.   
[Koren, 2001] Koren, I. (2001). Computer Arithmetic Algorithms. CRC Press, second edition.   
[Kreyszig, 2000] Kreyszig, E. (2000). Advanced Engineering Mathematics. Wiley, eigth edition.   
[Krick et al., 2000] Krick, R. F., Hinton, G. J., Upton, M. D., Sager, D. J., and Lee, C. W. (2000). Trace based instruction caching. US Patent 6,018,786.   
[Kumar, 2003] Kumar, V. R. (2003). Microprocessor x86 Programming. BPB.   
[Lafore, 2002] Lafore, R. (2002). Data Structures and Algorithms in Java. Sams Publishing.   
[Lin, 2011] Lin, M.-B. (2011). Introduction to VLSI Systems: A Logic, Circuit, and System Perspective. CRC Press.   
[Lindholm et al., 2008] Lindholm, E., Nickolls, J., Oberman, S., and Montrym, J. (2008). Nvidia tesla: A unified graphics and computing architecture. Micro, IEEE, 28(2):39–55.   
[Ling and Xing, 2004] Ling, S. and Xing, C. (2004). Coding Theory: A First Course. Cambridge University Press.   
[Mano, 2007] Mano, M. M. (2007). Computer Systems Architecture. Pearson.   
[Mezger et al., 2022] Mezger, B. W., Santos, D. A., Dilillo, L., Zeferino, C. A., and Melo, D. R. (2022). A survey of the risc-v architecture software support. IEEE Access, 10:51394–51411.   
[Micheli, 1994] Micheli, G. D. (1994). Synthesis and Optimization of Digital Circuits. McGrawHill.   
[Micheloni et al., 2010] Micheloni, R., Crippa, L., and Marelli, A. (2010). Inside NAND Flash Memories. Springer.   
[Mitra, 1999] Mitra, T. (1999). Dynamic random access memory: A survey. Department of Computer Science, State University of New York at Stony Brook, 25.   
[Muchnick, 1997] Muchnick, S. (1997). Advanced Compiler Design and Implementation. Morgan Kaufmann.   
[Neubauer et al., 2007] Neubauer, A., Freudenberger, J., and Kuhn, V. (2007). Coding Theory: Algorithms, Architectures and Applications. Wiley-Blackwell.   
[Owen and Steinman, 2008] Owen, J. and Steinman, M. (2008). North bridge architecture of amd’s griffin microprocessor family. Micro, IEEE, 28(2):10–18.   
[Parhami, 2009] Parhami, B. (2009). Computer Arithmetic: Algorithms and Hardware Designs. Oxford University Press.   
[Patsidis et al., 2020] Patsidis, K., Nicopoulos, C., Sirakoulis, G. C., and Dimitrakopoulos, G. (2020). Risc-v 2: a scalable risc-v vector processor. In 2020 IEEE International Symposium on Circuits and Systems (ISCAS), pages 1–5. IEEE.   
[Patt and Patel, 2003] Patt, Y. and Patel, S. (2003). Introduction to Computing Systems: From bits & gates to C & beyond. McGraw-Hill.   
[Patterson and Waterman, 2017] Patterson, D. and Waterman, A. (2017). The risc-v reader: an open architecture atlas.   
[Paul, 1993] Paul, R. (1993). SPARC Architecture, Assembly Language Programming and  . Prentice Hall.   
[Peterson et al., 1991] Peterson, C., Sutton, J., and Wiley, P. (1991). iwarp: a 100-mops, liw microprocessor for multicomputers. Micro, IEEE, 11(3):26–29.   
[Petric et al., 2005] Petric, V., Sha, T., and Roth, A. (2005). Reno: A rename-based instruction optimizer, volume 33. IEEE Computer Society.   
[Phelps and Parks, 2004] Phelps, A. M. and Parks, D. M. (2004). Fun and Games: MultiLanguage Development. Queue, 1(10):46–56.   
[Pratt, 1995] Pratt, V. (1995). Anatomy of the pentium bug. In TAPSOFT’95: Theory and Practice of Software Development, pages 97–107. Springer.   
[Proakis and Salehi, 2007] Proakis, J. and Salehi, M. (2007). Digital Communications. McGrawHill.   
[Quinn, 2003] Quinn, M. (2003). Parallel Programming in  with OpenMP and MPI. Tata McGrawHill.   
[Qureshi et al., 2011] Qureshi, M. K., Gurumurthi, S., and Rajendran, B. (2011). Phase change memory: From devices to systems. Synthesis Lectures on Computer Architecture, 6(4):1–134.   
[Radhakrishnan et al., 2007] Radhakrishnan, S., Chinthamani, S., and Cheng, K. (2007). The blackford north bridge chipset for the intel 5000. Micro, IEEE, 27(2):22–33.   
[Ramı´rez et al., 2020] Ramı´rez, C., Hern´andez, C. A., Palomar, O., Unsal, O., Ramı´rez, M. A., and Cristal, A. (2020). A risc-v simulator and benchmark suite for designing and evaluating vector architectures. ACM Transactions on Architecture and Code Optimization (TACO), 17(4):1–30.   
[russell, 1978] russell, r. m. (1978). the cray-1 computer system. communications of the acm, 21(1):63–72.   
[Sarangi, ] Sarangi, S. R. Next-Gen Computer Architecture. White Falcon, 1st edition edition.   
[Sarangi et al., 2014] Sarangi, S. R., Ananthanarayanan, G., and Balakrishnan, M. (2014). Lightsim: A leakage aware ultrafast temperature simulator. In ASPDAC.   
[Sarangi et al., 2006] Sarangi, S. R., Tiwari, A., and Torrellas, J. (2006). Phoenix: Detecting and recovering from permanent processor design bugs with programmable hardware. In Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture, pages 26–37. IEEE Computer Society.   
[Silberschatz et al., 2008] Silberschatz, A., Galvin, P. B., and Gagne, G. (2008). Operating System Concepts. Wiley, 8 edition.   
[Sima et al., 1997] Sima, D., Fountain, T., and Karsuk, P. (1997). Advanced Computer Architectures: A Design Space Approach. Addison-Wesley.   
[Singh and Sarangi, 2021] Singh, S. S. and Sarangi, S. R. (2021). Isamod: A tool for designing asips by comparing different isas. In 2021 34th International Conference on VLSI Design and 2021 20th International Conference on Embedded Systems (VLSID), pages 1–6. IEEE.   
[Sklar, 2001] Sklar, B. (2001). Digital Communications: Fundamentals and Applications. Prentice Hall.   
[Smith and Sohi, 1995] Smith, J. E. and Sohi, G. S. (1995). The microarchitecture of superscalar processors. Proceedings of the IEEE, 83(12):1609–1624.   
[Snir et al., 1995] Snir, M., Otto, S. W., Walker, D. W., Dongarra, J., and Huss-Lederman, S. (1995). MPI: the complete reference. MIT press.   
[Sorin et al., 2011] Sorin, D. J., Hill, M. D., and Wood, D. A. (2011). A primer on memory consistency and cache coherence. Synthesis Lectures on Computer Architecture, 6(3):1–212.   
[Srinivasan et al., 2004] Srinivasan, J., Adve, S. V., Bose, P., and Rivers, J. A. (2004). The case for lifetime reliability-aware microprocessors. In Proceedings of the 31st annual international symposium on Computer architecture, ISCA ’04, pages 276–.   
[Stallings, 2010] Stallings, W. (2010). Computer Organization and Architecture: Designing for Performance. Pearson.   
[Stangherlin and Sachdev, 2022] Stangherlin, K. and Sachdev, M. (2022). Design and implementation of a secure risc-v microprocessor. IEEE Transactions on Very Large Scale Integration (VLSI) Systems, 30(11):1705–1715.   
[Stenstrom, 1990] Stenstrom, P. (1990). A survey of cache coherence schemes for multiprocessors. Computer, 23(6):12–24.   
[Streetman and Banerjee, 2005] Streetman, B. and Banerjee, S. (2005). Solid State Electronic Devices. Prentice-Hall.   
[Sze and Ng, 2006] Sze, S. M. and Ng, K. K. (2006). Physics of semiconductor devices. WileyInterscience.   
[Tanenbaum, 2007] Tanenbaum, A. S. (2007). Modern Operating Systems. Prentice Hall, third edition.   
[Tarjan et al., 2006] Tarjan, D., Thoziyoor, S., and Jouppi, N. P. (2006). Cacti 4.0. HP laboratories, Technical report.   
[Taub and Schilling, 1977] Taub, H. and Schilling, D. L. (1977). Digital integrated electronics. McGraw-Hill New York.   
[Verma et al., 2008] Verma, A. K., Brisk, P., and Ienne, P. (2008). Variable Latency Speculative Addition: A New Paradigm for Arithmetic Circuit Design. In DATE, pages 1250–1255.   
[von Neumann, 1945] von Neumann, J. (1945). First Draft of a Report on the EDVAC. Technical report.   
[Vranas et al., 2006] Vranas, P., Bhanot, G., Blumrich, M., Chen, D., Gara, A., Heidelberger, P., Salapura, V., and Sexton, J. C. (2006). The BlueGene/L Supercomputer and Quantum ChromoDynamics. In Proceedings of the 2006 ACM/IEEE conference on Supercomputing, SC ’06, New York, NY, USA. ACM.   
[Wakerly, 2000] Wakerly, J. F. (2000). Digital design: principles and practices. Prentice-Hall, Inc.   
[Ware et al., 2010] Ware, M., Rajamani, K., Floyd, M., Brock, B., Rubio, J. C., Rawson, F., and Carter, J. B. (2010). Architecting for power management: the ibm R⃝ power7  approach. In High Performance Computer Architecture (HPCA), 2010 IEEE 16th International Symposium on, pages 1–11. IEEE.   
[Waterman, 2016] Waterman, A. S. (2016). Design of the RISC-V instruction set architecture. University of California, Berkeley.   
[Wessman et al., 2021] Wessman, N.-J., Malatesta, F., Andersson, J., Gomez, P., Masmano, M., Nicolau, V., Le Rhun, J., Cabo, G., Bas, F., Lorenzo, R., et al. (2021). De-risc: the first risc-v space-grade platform for safety-critical systems. In 2021 IEEE space computing conference (SCC), pages 17–26. IEEE.   
[Whitesitt, 2010] Whitesitt, J. E. (2010). Boolean Algebra and its Applications. Dover Books on Computer Science.   
[Wikipedia, ] Wikipedia. Dadda multiplier. http://en.wikipedia.org/wiki/Dadda_ multiplier. Accessed on Oct 22nd, 2012.   
[Yeager, 1996] Yeager, K. (1996). The mips r10000 superscalar microprocessor. Micro, IEEE, 16(2):28–41.   
[Yeh and Patt, 1991] Yeh, T.-Y. and Patt, Y. N. (1991). Two-level adaptive training branch prediction. In Proceedings of the 24th annual international symposium on Microarchitecture, pages 51–61. ACM.   
[Yeh and Patt, 1992] Yeh, T.-Y. and Patt, Y. N. (1992). Alternative implementations of twolevel adaptive branch prediction. In ACM SIGARCH Computer Architecture News, volume 20, pages 124–134. ACM.   
[Yeh and Patt, 1993] Yeh, T.-Y. and Patt, Y. N. (1993). A comparison of dynamic branch predictors that use two levels of branch history. ACM SIGARCH Computer Architecture News, 21(2):257–266.   
[Yiu, 2009] Yiu, J. (2009). The Definitive Guide to ARM Cortex-M3. Newnes.   
[Yiu, 2011] Yiu, J. (2011). The Definitive Guide to ARM Cortex-M0. Newnes.   
[Yourst, 2007] Yourst, M. (2007). Ptlsim: A cycle accurate full system x86-64 microarchitectural simulator. In ISPASS, pages 23–34.

Index

1’s Complement, 65   
2 Phase Handshaking, 668   
2’s Complement, 67 alternative representation, 73 properties, 70 overflow checking, 73 sign extension, 72   
2-bit Saturating Counter, 489   
2-bit Saturating Counter-Based Branch Predictor, 489   
2.5D Memory Organization, 288   
4 Phase Handshaking, 667

, 447

Access Graph, 606   
Addition, 305   
Address Distance, 513   
Address format, 103   
Addressing mode, 104, 105 base-index, 105 base-index-offset, 105 immediate, 105 memory-direct, 105 memory-indirect, 105 register, 105 register-indirect, 105   
Ageing, 480   
ALU, 361   
Ambient Temperature, 485   
AMD Bobcat, 741   
AMD Bulldozer, 743   
Amdahl’s Law, 578   
Ancient Number Systems, 57 Indian numerals, 58 Roman numerals, 58   
Antifuse, 294   
Arbiter, 677   
Arbitration, 676 bus grant signal, 677 bus request signal, 677 star topology, 677   
Arbitration Policy, 677   
Architecture, 14   
ARM condition code, 153 condition codes, 152 CPSR register, 146 instruction encoding, 163 shifter operand, 145   
ARM assembly, 139   
ARM Cortex-A15, 738   
ARM Cortex-A8, 736   
ARM Cortex-M3, 734   
ARM instruction adc, 147 add, 141 and, 141 b, 148 beq, 148 bic, 141 bl, 150 bne, 148 branch instructions, 148 cmn, 147 cmp, 147 conditional instruction, 152 eor, 141 ldmfd, 160 ldr, 155 mla, 142 mov, 140 mul, 142 mvn, 140 orr, 141 rsb, 141 rsc, 147

Booth Multiplier, 324   
Branch Prediction, 487   
Branch Target Buffer, 489   
Bss Section, 545   
Bubble, 435   
Buffering, 669   
Burst Error, 675   
Burst Mode, 690   
Bus, 382   
Bus Controller, 649   
Bus Frequency, 654   
Bus Master, 677   
Bus Transaction, 681   
Byte, 39, 47   
Byte Stuffing, 670

sbc, 147 smull, 142 stmfd, 160 str, 155 sub, 141 teq, 147 tst, 147 umull, 142 ARM instruction set, 139 machine model, 139 registers, 139 Array of CAM Cells, 290 Array of DRAM Cells, 293 Array of SRAM Cells, 287 ASCII format, 82 Assembler, 95 Assembly language, 94 generic statement structure, 102 label, 102 statement, 100 Assembly language file structure, 100 Associativity Rule, 539 Asymmetric Multiprocessing, 569 Asymptotic time complexity, 310 Asynchronous Bus, 665 Asynchronous I/O, 666 clock detection, 665 clock recovery, 665 Atomic Instruction, 187 Atomicity, 589 Back Side Bus, 650 Backplane Bus, 650 Backward Error Correction, 671 Bias Based Representation, 66 Big endian, 98 Binary, 19 Binary Number System, 59 Bisection Bandwidth, 625 Bit, 39, 47 Bit Error Rate, 670 Bit Line, 287 Bit Period, 657 Bit Stuffing, 670 Boolean Algebra, 50

Cache, 516 associativity, 524 cache hit, 516 cache miss, 516 data read operation, 528 data write operation, 528 global miss rate, 536 insert operation, 529, 530 local miss rate, 536 lookup, 520 operations, 519 replacement policy, 530 replacement schemes, 530 way, 524 write back, 528 write through, 528   
Cache Bank, 598   
Cache Coherence, 596, 598 directory protocol, 601 write-invalidate protocol, 602 write-update protocol, 600   
Callee, 116   
Caller, 116   
CAM Cell, 289 match line, 289   
Card, 648   
Carry, 306   
Carry lookahead adder, 314   
Carry select adder, 313

Case Studies, 733   
Channel, 267   
Charge Carriers, 265   
electron, 265   
hole, 265   
Checkerboard Design, 622   
Chip Package, 480   
Chipset, 649   
Church Turing Thesis, 26   
CISC, 21   
Clock, 279   
Clock Detection, 665   
Clock Recovery, 665   
Clocked SR Latch, 280   
Cluster Computer, 625   
CMOS Logic, 268   
Coarse-Grained Multithreading, 611   
Code Reordering, 430   
Coherence, 584   
axioms, 584   
Column major, 99   
Comma, 670   
Compiler, 92   
Computer, 14   
Computer arithmetic, 305   
Consensus Rule, 52   
Constant Linear Velocity, 716   
Content Addressable Memory, 289   
Context of a Program, 461   
Control Hazard, 427   
Control Path, 363   
Control Unit, 375   
CPI, 467   
CPU, 16   
Critical Word First, 540   
Cross-compiler, 93   
Crosstalk, 670   
CUDA, 760, 762   
block, 762   
CTA, 762   
grid, 762   
kernel, 760   
program, 762   
Current Privilege Level (CPL), 464   
Cycle Stealing Mode, 690

Cyclic Redundancy Check (CRC) Codes, 675   
D Flip-flop, 283   
Daisy Chain Based Arbitration, 6   
Daisy Chain Bus, 678   
Data Array, 520   
Data Hazard, 426 RAW hazard, 426 WAR hazard, 426 WAW hazard, 426   
Data Lane, 618   
Data Link Layer, 669   
Data Path, 363   
Data Section, 545   
Data Strobe Encoding, 699   
DDR Memory, 293 DDR 1, 293 DDR 2, 293 DDR 3, 293   
De Morgan’s Laws, 52   
Decoder, 272   
decoder, 131   
Decoding, 360   
Delay Slot, 432   
Delayed Branch, 432   
Demultiplexer, 274   
Denormal Numbers, 79   
Device Driver, 543   
Diffusion, 266   
Digital Logic, 263   
Diode, 266   
Direct Mapped Cache, 522   
Direct Memory Access, see DMA   
Directory, 601   
Directory Protocol, 601   
Displacement, 184   
Division, 333   
DMA, 689 burst mode, 690 cache snoop engine, 690 cycle stealing mode, 690   
Doping, 265   
Double Precision Numbers, 80   
Drain, 267   
DRAM, 291

Drift, 266   
Dynamic Instruction, 469   
Dynamic Power, 481   
Dynamic RAM (DRAM), 291   
Dynamic Voltage Frequency Scaling   
486   
Dynamically Loaded Libraries, 546

Early Restart, 540   
Edge Sensitive, 281   
Edge Sensitive SR Flip-flop, 281   
EEPROM, 717   
Effective memory address, 106   
Encoder, 274   
Energy Delay  , 485   
EPIC, 493   
EPROM, 717   
Error Detection and Correction, 670   
Exception, 458   
Executable, 19   
Execute Unit, 369   
Fail Stop Failure Model, 710   
FC (Fiber Channel) , see also SCSI   
fcsr, 245   
Feature Size, 571   
Fetch Unit, 361   
fflags, 245   
Fine-Grained Multithreading, 613   
FireWire Protocol, 699   
Firmware, 381   
Flash program/erase cycle, 722   
Flash Memory, 717 block, 721 floating gate transistor, 718 page, 721 read disturbance, 723 wear leveling, 722   
Flip-flop, 280   
Floating Gate Transistor, 718   
Floating point addition opposite signs, 346   
Floating Point Control and Status 245   
Floating point division, 349

Goldschmidt division, 349 Newton-Raphson division, 350 simple method, 349 Floating Point Mathematics, 81 Floating point multiplication, 347 Floating Point Numbers, 74 binary, 75 IEEE 754 format, 77 normal form, 76 special numbers, 78 Floating Point Rounding, 344 Floating point subtraction, 346 Flynn’s Classification, 580 Forward Bias, 266 Forward Error Correction, 671 Forwarding, 442 Forwarding Conditions, 452 Forwarding Unit, 453 Frame, 550 Framing, 669 Front Side Bus, 650 Full Adder, 306 Full Duplex Bus, 680 Fully Associative Cache, 520

GCC Intrinsics, 618   
Generate function, 314   
Generic I/O Device, 644   
GFLOPS, 476   
Global Descriptor Table (GDT), 181   
Global Miss Rate, 536   
Goldschmidt division, 349   
GPU, see Graphics Processors   
Graphics Pipeline, 755 depth buffering, 755 rendering, 755   
Graphics Processors, 753 CUDA programming model, see CUDA

Half adder, 306   
Half Duplex Bus, 680   
Hamming Code, 675   
Hamming Distance, 675   
Happens Before Relationship, 606   
Hard Disk, 703   
cylinder, 707

head, 704 platter, 704 read head, 704 rotational latency, 709 seek time, 709 servo control, 708 track, 704 transfer time, 709 write head, 704 zoned-bit recording(zbr), 706   
Hardwired Control Unit, 375   
Harvard Architecture, 34   
Hazard control, 427 data, 426 structural, 429   
Hazards, 422   
Heap, 546   
Heat Sink, 480   
Hexadecimal Number System, 60   
High level language, 92   
Hold Time, 284   
Horizontal Microprogramming, 406   
Hyperthreading, 614   
I/O Address Space, 683   
I/O and Storage, 643   
I/O Case Studies, 690   
I/O Clock, 657   
I/O Devices, 643   
I/O Layers, 652 data link layer, 652 network layer, 652 physical layer, 652 protocol layer, 652   
I/O Port, 643, 644 software interface, 682   
I/O Port Addressing port-mapped I/O, 685 memory-mapped i/o, 686   
I/O Routing Table, 685   
IDE (Integrated Drive Electronics), 693   
IEEE 754 Format, 77 denormal numbers, 79 infinity, 78

NAN, 78 ILP, 496 Immediate, 100 In-order Pipeline, 426 Inorder Pipeline, 491 Inorder Processor, 491 Instruction definition, 18 Instruction format branch, 127 immediate, 128 register, 128 Instruction Level Parallelism, 496 Instruction Packet, 418 Instruction Queue, 495 Instruction Select, 495 Instruction set architecture, 19 complete, 20 concise, 20 generic, 21 multiple instruction ISA, 31 simple, 21 Single Instruction ISA, 30 Instruction Wakeup, 495 Instruction Window, 495 Intel 8086, 175 Intel Atom, 746 Intel Sandy Bridge, 748 Interconnection Networks, see Network-on-Chip Interrupt, 457 Interrupt Handler, 457 interrupt masking, 688 Interrupts, 688 Inverted Page Table, 553 Inverter, 268 IPC, 469 ISA, 19 Iterative Multiplier, 320 JK Flip-flop, 282 Karnaugh Maps, 54

Kernel, 543   
KIPS, 476   
Last Level Cache (LLC), 598

Leakage Current, 483   
Leakage Power, 483   
Level Sensitive, 281   
Linear Memory Model, 180   
Link, 623   
Little endian, 98   
Load Store Queue, 495   
Local Descriptor Table (LDT), 181   
Local Miss Rate, 536   
Logic Gates, 52   
Logical Operator and, 49 nand, 50 nor, 50 not, 49 or, 49 xor, 51   
Logical Operators, 49   
Loop Buffer, 739   
Loosely Coupled Multiprocessing, 572   
Low level programming language, 94   
LSB, 60   
LVDS (Low Voltage Differential Signaling) , 655   
Main Memory, 515   
Manchester Encoding, 658   
Master Slave Flip-flop, 281   
Master-slave D Flip-flop, 283   
Memory, 286 theoretical definition, 29   
Memory Access Unit, 372   
Memory Consistency, 585   
Memory Management Unit, 555   
Memory Map, 544   
Memory Model, 586   
Memory System, 507 average memory access time, 536 performance, 535   
Memory-Mapped Files, 546   
Memory-Mapped I/O, 685, 686   
MESI Protocol, 605   
Mesochronous Bus, 661   
Metastability, 284   
MFLOPS, 476   
Microassembly Language, 387   
Microcode, 380   
Microcode Preamble, 391   
Microcontrol Unit, 387   
Microinstruction, 380   
Microprogram Counter, 387   
Microprogram Memory, 387   
Microprogrammed Processor, 380 decode unit, 383 register file, 384   
Microprogrammed processor alu, 385 data path, 382, 386 fetch unit, 383 memory unit, 386   
Microprogramming, 380   
MIMD, 580   
minterm, 54   
MIPS, 476   
MISD, 580   
MMU, 555   
Modifiers, 124   
Moore’s Law, 570   
Motherboard, 649   
MPMD, 580   
MSB, 60   
MSI Protocol, 600   
Multicomputer, 572   
Multicore, 569   
Multidrop Bus, 679   
Multiple instruction ISA, 31   
Multiple Issue In-Order Pipeline, 491   
Multiplexer, 272   
Multiplication, 319 multiplicand, 319 multiplier, 319 product, 319   
Multiprocessing, 569   
Multiprocessor Systems, 567   
Multithreaded Processors, 610   
Multithreading, 610   
N-type Semiconductor, 265   
NAND Gate, 269

NASM, 184

NBTI, 480   
Need for a Fast Memory System, 508   
Negative Integers, 65 1’s complement , 65 2’s complement , 67 bias-based representation, 66 sign magnitude representation, 65   
Network Diameter, 625   
Network Layer, 682   
Network-on-Chip, 622 butterfly, 630 chain, 625 fat tree, 626 folded torus, 629 hypercube, 629 mesh, 627 ring, 625 torus, 627   
Newton-Raphson division, 350   
NMOS Transistor, 267 channel, 267 drain, 267 source, 267   
NOC, see Network-on-Chip   
Non Return to Zero (NRZ) Protocol, 659   
Non Return to Zero (NRZI) Inverted Protocol, 660   
Non-restoring division, 338   
Nop, 123, 430   
NOR Gate, 269   
Normal Form, 76   
North Bridge, 650   
Number Circle, 69   
NVIDIA Tesla Architecture, 756 computation on a GPU, 760 ROP (Raster Operations Processor), 758 SM, 758 SM (Streaming Multiprocessor), 759 TPC, 758 work distribution, 757   
O notation, 310   
oldSP, 462   
Opcode, 125   
Operand Fetch Unit, 364, 366   
Operating System, 543   
Optical Disk, 713 Blu-ray, 713 CD, 713 DVD, 713 layers, 715 physics, 714 reader, 715   
Optical disk constant linear velocity, 716   
organization, 14   
Out-of-order Pipeline, 426, 494   
Out-of-order Processor, 494 instruction queue, 495 instruction select, 495 instruction wakeup, 495 instruction window, 495 load store queue, 495 register renaming, 495 reorder buffer, 495   
Overflow, 67   
Overlap Problem, 548   
P-N Junction, 266   
P-type Semiconductor, 265   
Page, 550   
Page Fault, 556   
Page Table, 550 single level, 550 two level, 552   
Parity Bit, 671   
Partial product, 319   
Partial sum, 319   
PATA (Parallel ATA), 693   
PC, 96   
PCI Express, 691 expansion slots, 692 lane, 691 striping, 691   
Performance, 467   
Performance Equation, 469   
Performance of a Non-Ideal Pipeline, 472

Octal Number System, 60   
oldFlags, 462   
oldPC, 461   
Performance of an Ideal Pipeli   
Peripherals, 643   
Persistent State, 701   
PFLOPS, 476   
Phase Locked Loop (PLL), 665   
Physical Address, 549   
Physical Address Space, 535   
Physical Layer, 652   
Physical Memory, 515   
Physical View of Memory, 595   
Pipeline, 415   
exceptions, 457   
interrupts, 457   
Pipeline Bubble, 435   
Pipeline Diagram, 422   
Pipeline Flush, 488   
Pipeline Hazards, 422   
Pipeline Interlock, 433   
Pipeline Latch, 417   
Pipeline Register, 417   
Pipeline Stall, 433   
Pipelined Processor, 413, 415   
Pipelining, 413–415   
interlocks, 433   
PLA, 295   
AND plane, 298   
cell, 296   
OR plane, 298   
Plesiochronous Bus, 662   
PMOS Transistor, 268   
Point-to-Point Bus, 679   
Polling, 687   
Port, 367   
Port-Mapped I/O, 685   
Positive Integers, 57   
Power, 479   
dynamic power, 481   
Power Wall, 479   
Precharging, 288   
Precise Exceptions, 459   
Predicated Instructions, 621   
Prefetcher, 538   
Primary Page Table, 552   
Priority Encoder, 276   
Private Cache, 595

Privileged Instruction, 463   
Process, 576   
process, 542   
Process Management, 543   
Processor, 16 execution unit, 369 instruction fetch, 361 memory access unit, 372 operand fetch unit, 364 register writeback unit, 374   
Processor Design, 359   
Program counter, 32   
Program Order, 491, 586   
Program State, 461   
Programmable Interrupt Controller (PIC), 688   
Programmable Logic Array, see PLA   
PROM (Programmable ROM) Memories, 294   
Propagate function, 314   
Protocol Layer, 686   
RAID, 709 data striping, 710 distributed parity, 713 RAID 0, 710 RAID 1, 710 RAID 2, 711 RAID 3, 712 RAID 4, 712 RAID 5, 713 RAID 6, 713   
RAID Arrays, see RAID   
Read Only Memory (ROM), 293   
Reduce Operation, 578   
Refresh Rate, 753   
Register File, 361   
Register Renaming, 427, 495   
Register spilling, 117   
Register transfer notation, 105   
Register Window, 464   
Register Writeback Unit, 374   
Registers, 285 parallel in–parallel out, 285 serial in–parallel out, 286   
Renormalization, 346   
Reorder Buffer, 495   
Replacement Policy SATA (Serial ATA), 693 fifo, 530 Scatter-Gather Operation, 617 lru, 531 SCSI, 693 pseudo lru, 531 LUN, 695 random, 530 SCSI (Small Computer System Interface)   
Restoring division, 334 SDRAM (synchronous DRAM), 293   
Return address, 115 SEC code, 674   
Return Address Stack, 739 sec:ioport, 682   
Return to Zero(RZ) Protocol, 657 SECDED, 675   
Reverse Bias, 266 Secondary Page Table, 552   
Ripple carry adder, 309 Seek Time, 709   
RISC, 21 Segment Descriptor Cache, 181   
RISC-V, 225 Segmented Memory Model, 180 addition and subtraction instructions, 231 Self Clocked Signal, 659 conditional branches, 235 Sense Amplifiers, 288 instruction encoding, 251 Sequential Consistency, 587 integer instructions, 229 Sequential Logic, 277 load and store instructions, 241 Serial Interconnect, 691 logical and shift instructions, 233 Set Associative Cache, 524 machine model, 226 Setup Time, 284 moving values, 229 Shaders, 756 multiplication and division instructions, 232 Shared Cache, 595 registers, 228 Shared Caches, 598 unconditional branches, 239 Shared Microprogram Bus, 402   
RISC-V branch instructions, 235 read bus, 402   
RISC-V floating point instructions, 245 write bus, 402 arithmetic, 248 Shift and rotate instructions, 144 comparison, 250 Shift Register, 286 conversion, 249 Sign Extension, 72 flags, 246 Sign Magnitude Representation, 65 loads and stores, 247 Silicon-Based Transistors, 264 registers, 245 SIMD, 580 rounding modes, 246 SIMD Multiprocessors, 614   
ROB, 495 Simple Synchronous Bus, 661   
Rotational Latency, 709 SimpleRisc, 107   
Rounding, 344 arithmetic instructions, 108   
Router, 623 call and return instructions, 121   
Row major, 99 conditional branch instruction, 112 encoding, 125   
SAS, 694 instruction formats, 131 initiator, 695 load and store instructions, 111 nearline SAS, 695 logical instructions, 110 target, 695 machine model, 108   
SAS , see also SCSI modifiers, 124   
SAS (Serially Attached SCSI), see SCSI register transfer instruction, 108

Superscalar, 491   
Swap Space, 554   
Symmetric Multiprocessing, 569   
Synchronization Sublayer, 661   
Synchronous Bus, 661   
delay element, 662   
Syndrome, 673   
System on Chip (SOC), 651   
System Utilities, 543   
Systolic Array, 615   
T State, 436   
Tag Array, 520   
Temperature, 479, 484   
Temporal Locality, 510   
Ternary Signaling, 656   
Text Section, 545   
TFLOPS, 476   
Thermal Interface Material (TIM), 480   
Thermal Resistance Matrix, 485   
Thread, 575   
hardware, 612   
software, 612   
Tiles, 622   
Transaction-Oriented Buses, 679   
Transfer Multiplexer, 402   
Transfer Time, 709   
Transmission of Multiple Bits, 656   
Transmission Sublayer, 652   
Turing Complete, 28   
Turing Machine, 23   
Types of instructions, 103   
shift instructions, 110   
unconditional branch instruction, 1   
Simultaneous Multithreading, 613   
Single Ended Signaling, 654   
Single Error Correction (SEC), 672   
Single Error Detection, 671   
Single instruction ISA, 30   
SISD, 580   
Size Problem, 548   
Sizes of Integers, 63   
Slice, 622   
SMP, 569   
SMT, see Simultaneous Multithreading   
Soft Errors, 710   
Software Solutions to Hazards, 430   
Source, 267   
Source Synchronous Bus, 664   
South Bridge, 650   
Spatial Locality, 510   
SPEC Benchmarks, 475   
Speculative Instructions, 487   
Split Transaction Buses, 681   
SPMD, 580   
Spreader, 480   
Square Root Rule, 539   
SR Latch, 277   
SRAM, 286   
SRAM Cell, 286   
Stack, 118, 546   
Stack Distance, 511   
Static Instruction, 469   
Static Power, see Leakage Power   
Static RAM (SRAM), 286   
Storage, 701   
Stored Program Concept, 35   
Strings, 82   
ascii, 82   
unicode, 82   
Strip Mining, 619   
Striping, 691   
Strobe Signal, 666   
Strongly Coupled Multiprocessing, 572   
Structural Hazard, 429   
Subtract and branch if negative, 30   
Sum, 306

Underflow, 67   
Unicode format, 82   
Universal Machine, 23   
Universal Turing Machine, 27   
USB end point, 698 hub, 696 pipe, 699 split transaction bus, 698   
UTF-16, 83   
UTF-32, 83   
UTF-8, 82   
Vector Processors, 615 design, 622   
Vectored Interrupt, 688   
Vertical Microprogramming, 404   
Victim Cache, 538   
Virtual , 548   
Virtual Address, 549   
Virtual Machine, 738   
Virtual Memory, 541, 544 size problem, 548   
VLIW, 493   
Von Neumann Architecture, 34 accumulator, 38 registers, 36 stack, 37   
Wallace tree multiplier, 331   
Weak Consistency, 587   
Weak Memory Model, 588   
Wear Leveling, 722, 723   
Word, 39   
word line, 286   
Working Set, 537   
Write Buffer, 539   
Write-Invalidate Protocol, 602   
Write-Update Protocol, 600   
Wrong Path, 428   
x86, 175 32-bit, 178 64-bit, 178 addressing modes, 182 eflags, 179 floating point arithmetic instructions, 210 floating point exchange, 209 floating point load, 208 floating point registers, 179 floating point stack, 179 floating point store, 209 machine model, 177 memory operands, 183 nasm, 184 register set, 177 rep instructions, 205 string instructions, 203   
x86-64, 176, 178

XOR Gate, 271   
Zoned-Bit Recording(ZBR), 706