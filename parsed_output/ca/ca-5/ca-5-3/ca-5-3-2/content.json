[
    {
        "type": "text",
        "text": "5.3.2 ALU Instructions ",
        "text_level": 1,
        "page_idx": 191
    },
    {
        "type": "text",
        "text": "Let us now discuss the rich set of ALU instructions that x86 processors support. ",
        "page_idx": 191
    },
    {
        "type": "text",
        "text": "Add and Subtract Instructions ",
        "text_level": 1,
        "page_idx": 191
    },
    {
        "type": "text",
        "text": "Table 5.8 shows the add and subtract operations that are typically used in x86 processors. The basic add and subtract instructions add the values of the first and second operands, and treat the first operand also as the destination operand. They set the carry and overflow fields of the eflags register. The adc instruction adds its two source operands, and also adds the value of the carry bit. Similarly, the $s b b$ instruction subtracts the second operand from the first, and then subtracts the carry bit from the result. We can use the adc and sbb instructions to add or subtract very large integers (refer to Example 62 and Example 63). In these examples, we first operate on the lower bytes. While operating on the higher bytes we need to take the carry generated by adding or subtracting the lower bytes into account. We use the adc and $s b b$ instructions, respectively for this purpose. ",
        "page_idx": 191
    },
    {
        "type": "table",
        "img_path": "images/fd0d4674df3d7ae871e8f1ae77ae32f37c33e8d2f0c1582f02eff956a182e2a0.jpg",
        "table_caption": [
            "Table 5.8: Semantics of add and subtract instructions "
        ],
        "table_footnote": [],
        "table_body": "\n\n<html><body><table><tr><td>Semantics</td><td>Example</td><td>Explanation</td></tr><tr><td>add (reg (mem), (reg/mem/imm</td><td>add eax, ebx</td><td>eax \u2191 eax +ebx</td></tr><tr><td>sub (reg (mem) (reg/ (mem/imm)</td><td>sub eax, ebx</td><td>eax \u2191 eax- ebx</td></tr><tr><td>adc (reg /mem) (reg mem/ imm)</td><td>adc eax, ebx</td><td>eax \u2191 eax \u5341 ebx + (carry bit)</td></tr><tr><td>sbb (reg (mem) (reg mem imm)</td><td>sbb eax, ebx</td><td>eax \u2191 eax ebx- (carry bit)</td></tr></table></body></html>\n\n",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "Example 62 ",
        "text_level": 1,
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "Write an x86 assembly program to add two 64-bit numbers. The first number is stored in the registers ebx, and eax, where ebx stores the higher byte, and eax stores the lower byte. The second number is stored in edx, and ecx. Save the result in ebx (higher byte), and eax(lower byte). ",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "Answer: ",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "add eax, ecx adc ebx, edx ",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "Example 63 ",
        "text_level": 1,
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "Write an x86 assembly program to subtract two 64-bit numbers. The first number is stored in the registers ebx, and eax, where ebx stores the higher byte, and eax stores the lower byte. The second number is stored in edx, and ecx. Subtract the second number from the first number. Save the result in ebx (higher byte), and eax(lower byte). ",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "Answer: ",
        "text_level": 1,
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "sub eax, ecx sbb ebx, edx ",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "inc, dec, and neg Instructions ",
        "page_idx": 192
    },
    {
        "type": "text",
        "text": "Table 5.9 shows the semantics of increment (inc), decrement (dec), and negate $( n e g )$ instructions. The inc instruction, adds 1 to the source operand. In this case also the source and destination operands are the same. Similarly, the dec instruction subtracts 1 from the source operand, which is also the destination operand. Note that the operand can either be a register or a memory location. The $n e g$ instruction computes the negative of the value stored in the first operand (register or memory). Let us consider an example (see Example 64). ",
        "page_idx": 192
    },
    {
        "type": "table",
        "img_path": "images/00470c0e71457d62048b629f773ec6cc44edb6f97be5ba6946d053ea43d3be74.jpg",
        "table_caption": [
            "Table 5.9: Semantics of inc, dec, and neg instructions "
        ],
        "table_footnote": [],
        "table_body": "\n\n<html><body><table><tr><td></td></tr><tr><td>Semantics</td><td>Example Explanation edx \u2190edx +1</td></tr><tr><td>inc (reg/mem) inc edx</td></tr><tr><td>dec edx edx \u2190edx-1</td></tr><tr><td>dec (reg/mem)</td></tr><tr><td>neg (reg/mem) neg edx edx \u2190 -1*edx</td></tr></table></body></html>\n\n",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "Example 64 ",
        "text_level": 1,
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "Write an x86 assembly code snippet to compute eax = -1 \\* (eax + 1). ",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "Answer: ",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "inc eax neg eax ",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "The Compare(cmp) Instruction ",
        "text_level": 1,
        "page_idx": 193
    },
    {
        "type": "table",
        "img_path": "images/98b9241ebee364acb5001cf89b27fe7e5bcd3635e1a76a8c8e88e63dc9252a68.jpg",
        "table_caption": [
            "Table 5.10: Semantics of the cmp instructions "
        ],
        "table_footnote": [],
        "table_body": "\n\n<html><body><table><tr><td>Semantics</td><td>Example</td><td>Explanation</td></tr><tr><td>cmp (reg/mem), (reg/mem/imm)</td><td>cmp eax,[ebx + 4]</td><td>compare the values in eax, and [ebx+4],and set the flags</td></tr><tr><td>cmp (reg/mem), (reg/mem/imm)</td><td>cmp ecx, 10</td><td>compare the contents of ecx with 10,and set the flags</td></tr></table></body></html>\n\n",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "Table 5.10 shows the cmp (compare) instruction. It compares two operands and sets the values of a few flags. It performs the comparison by subtracting the value of the second operand from the first operand. This is conceptually a subtract instruction that does not have a destination operand. ",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "Multiplication and Division Instructions ",
        "text_level": 1,
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "Table 5.11 shows the signed multiplication and division instructions in x86. They are known as imul and idiv, respectively. The unsigned variants of the instructions are known as mul and div. They have exactly the same semantics as their signed counterparts. The signed instructions are more generic. Hence, we only discuss their operation in this section. ",
        "page_idx": 193
    },
    {
        "type": "text",
        "text": "The imul instruction has three variants. The 1-address format variant has 1 source operand, which can either be a register or a memory address. This source operand is multiplied with the contents of $e a x$ . Note that when we multiply two 32-bit numbers, we require at most 64 bits to save the result (see Section 8.2.1). Hence, to avoid overflows, the processor saves the results in the register pair $( e d x , e a x )$ . edx contains the upper 32 bits, and eax contains the lower 32 bits of the final product. The 2-address format version is similar to other ALU instructions that we have studied. It multiplies the first and second source operands, and saves the result in the destination register (which is the first operand). Note that in this variant of the multiply instruction, the destination is always a register, and the result is truncated to fit in the register. The imul instruction has another variant that requires 3 operands. Here, it multiplies the contents of the second and third operands and stores the product in the register specified by the first operand. For this variant of the imul instruction, the first operand needs to be a register, the second operand can be a register or memory location, and the third operand needs to be an immediate value. ",
        "page_idx": 193
    },
    {
        "type": "table",
        "img_path": "images/0007207ab078acd5766786040563f1b87aeeb71d544f4aa433c8d3502f8f6b6a.jpg",
        "table_caption": [
            "Table 5.11: Semantics of the imul and idiv instructions "
        ],
        "table_footnote": [],
        "table_body": "\n\n<html><body><table><tr><td>Semantics</td><td colspan=\"4\">Example</td><td colspan=\"4\">Explanation</td></tr><tr><td> imul (reg/mem)</td><td colspan=\"4\">imul ecx</td><td colspan=\"4\">edx:eax \u2190 eax * ecx</td></tr><tr><td> imul reg, (reg/mem)</td><td>imul ecx,[eax + 4]</td><td colspan=\"3\"></td><td colspan=\"2\">ecx \u2190 ecx * [eax + 4]</td><td colspan=\"2\"></td></tr><tr><td>imul reg, (reg/mem),imm</td><td></td><td>imul ecx,[eax + 4],5</td><td></td><td></td><td colspan=\"2\">ecx \u2190 [eax\uff0b4] *5</td><td></td></tr><tr><td>idiv (reg/mem)</td><td colspan=\"4\">idiv ebx</td><td colspan=\"2\">tents of ebx; eax contains the</td><td>Divide (edx:eax) by the con-</td></tr><tr><td></td><td colspan=\"4\"></td><td colspan=\"4\">quotient,and edx contains the remainder.</td></tr></table></body></html>\n\n",
        "page_idx": 194
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 194
    },
    {
        "type": "text",
        "text": "The idiv instruction takes just 1 operand (register or memory). It divides the contents of the register pair (edx:eax) by the contents of the operand. It saves the quotient in $e a x$ , and the remainder in edx. Note that the remainder has the same sign as the dividend. A subtle point should be noted here. While using a positive dividend that fits in 32 bits, we need to explicitly set edx to 0, and for a negative dividend that fits in 32 bits, we need to explicitly set edx to -1 (for sign extension). ",
        "page_idx": 194
    },
    {
        "type": "text",
        "text": "Let us consider a set of examples. ",
        "page_idx": 194
    },
    {
        "type": "text",
        "text": "Example 65 Write an assembly code snippet to multiply 3 with -17, and save the result in eax. ",
        "page_idx": 194
    },
    {
        "type": "text",
        "text": "Answer: ",
        "text_level": 1,
        "page_idx": 194
    },
    {
        "type": "text",
        "text": "mov ebx, 3   \nimul eax, ebx, -17 ",
        "page_idx": 194
    },
    {
        "type": "text",
        "text": "Example 66 ",
        "text_level": 1,
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Write an assembly code snippet to compute $k ^ { 3 }$ , where $k$ is the content of ecx, and save the result in eax. ",
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Answer: ",
        "text_level": 1,
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "mov eax, ecx imul ecx imul ecx ",
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Example 67 ",
        "text_level": 1,
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Write an assembly code snippet to divide -50 by 3. Save the quotient in eax, and remainder in edx. ",
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Answer: ",
        "text_level": 1,
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "mov edx, -1 mov eax, -50 mov ebx, 3 idiv ebx ",
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "At the end eax contains -16, and edx contains -2. ",
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Logical Instructions ",
        "text_level": 1,
        "page_idx": 195
    },
    {
        "type": "table",
        "img_path": "images/9c118be3a0182e1207864fb902a822daf00a4ac8da48dbfc86876e043bfbc8d8.jpg",
        "table_caption": [
            "Table 5.12: Semantics of and, or, $x o r$ , and not instructions "
        ],
        "table_footnote": [],
        "table_body": "\n\n<html><body><table><tr><td>Semantics</td><td>Example</td><td>Explanation</td></tr><tr><td>and (reg/mem),(reg/mem/imm)</td><td>and eax, ebx</td><td>eax \u2190 eax AND ebx</td></tr><tr><td>or (reg/mem),(reg/mem/imm)</td><td>or eax,ebx</td><td>eax \u2190 eax OR ebx</td></tr><tr><td>xor (reg/mem), (reg/mem/imm)</td><td>xor eax,ebx</td><td>eax\u2190 eax XOR ebx</td></tr><tr><td>not (reg/mem)</td><td>not eax</td><td>eax\u2190 ~eax</td></tr></table></body></html>\n\n",
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Table 5.12 shows the semantics of four commonly used logical operations. and, or, and xor instructions have exactly the same format as add and sub instructions, and most of the other 2-address format instructions. They compute the bitwise AND, OR, and exclusive OR of the first two operands, respectively. The not instruction computes the 1\u2019s complement (flips each bit) of the source operand, which is also the destination operand (format is similar to other 1-address format instructions such as inc, dec, and neg). ",
        "page_idx": 195
    },
    {
        "type": "text",
        "text": "Shift Instructions ",
        "text_level": 1,
        "page_idx": 196
    },
    {
        "type": "table",
        "img_path": "images/51b8a06bb3ec333ebe8077b269e42ea2adbd8b2288e41e045a8ac0ebbcfb7d3b.jpg",
        "table_caption": [
            "Table 5.13: Semantics of shift instructions "
        ],
        "table_footnote": [],
        "table_body": "\n\n<html><body><table><tr><td>Semantics</td><td>Example</td><td>Explanation</td></tr><tr><td>sar (reg/mem),imm</td><td>sar eax, 3</td><td>eax\u2190 eax >> 3</td></tr><tr><td>shr (reg/mem),imm</td><td>shr eax, 3</td><td>eax\u2190 eax > 3</td></tr><tr><td>sal/shl (reg/mem),imm</td><td>sal eax, 2</td><td>eax\u2190 eax<2</td></tr></table></body></html>\n\n",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "Table 5.13 shows the semantics of shift instructions. sar (shift arithmetic right) performs an arithmetic right shift by replicating the sign bit. shr (shift logical right), shifts the first operand to the right. Instead of replicating the sign bit, it fills the MSB bits with 0s. sal and $s h l$ are the same instruction. They perform a left shift. Recall that we do not have an arithmetic left shift operation. Let us consider some examples. ",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "Example 68 What is the final value of eax? ",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "mov eax, 0xdeadc0de sal eax, 4 ",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "Answer: 0xeadc0de0 ",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "Example 69 What is the final value of eax?   \nmov eax, 0xdeadc0de   \nsar eax, 4   \nAnswer: 0xfdeadc0d ",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "Example 70 What is the final value of eax? ",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "mov eax, 0xdeadc0de shr eax, 4 ",
        "page_idx": 196
    },
    {
        "type": "text",
        "text": "Answer: 0xdeadc0d ",
        "page_idx": 196
    }
]