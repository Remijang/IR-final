9.3 The Control Unit

Table 9.4 shows the list of control signals that need to be generated by the control unit along with their associated conditions. The only control signal that is not generated by the control unit is isBranchT aken. This is generated by the branch unit that is a part of the execute unit. However, the rest of the 22 signals need to be generated by the control unit. Recall that the inputs to the control unit are the opcode of the instruction, and the value of the immediate bit.

The hardwired control unit for our simple processor can be thought of as a black box that takes 6 bits as input (5 opcode bits, and 1 immediate bit), and produces 22 control signals as its output. This is shown in Figure 9.16.

Internally, there are a set of logic gates that act on the input bits to produce each output bit. For example, to set the isAdd signal, we need to check if the opcode is equal to 00000. Let us number the five bits of the opcode as  ,  ,  ,  and  . Here  is the LSB, and  is the MSB. Let us refer to the immediate bit as  .

Table 9.5 shows the conditions for setting all the control signals. We leave the implementation of Table 9.5 using logic gates as an exercise to the reader. Note that it will take the maximum amount of time to compute the value of isW b. Nevertheless, this circuit is extremely simple as compared to a multiplier or a carry lookahead adder. Hence, the total execution time of the control unit is expected to be small as compared to the execute unit.

The hardwired control unit is thus fast and efficient. This is the reason why most commercial processors today use a hardwired control unit. However, hardwired control units are not very flexible. For example, it is not possible to change the behavior of an instruction, or even introduce a new instruction, after the processor has been shipped. Sometimes we need to change the way an instruction is executed if there are bugs in functional units. For example, if the multiplier has a design defect, then it is theoretically possible to run the Boothâ€™s multiplication algorithm with the adder, and shift units. We will however, need a very elaborate control unit to dynamically reconfigure the way instructions are executed.

There are other more practical reasons for favoring a flexible control unit. Some instruction sets such as x86 have rep instructions that repeat an instruction a given number of times. They also have complicated string instructions that operate on large pieces of data. Supporting such instructions requires a very complicated data path. In principle, we can execute such instructions by having elaborate control units that in turn have simple processors to process these instructions. These sub processors can generate control signals for implementing complicated

CISC instructions.

Way Point 6

1. We have successfully designed a hardwired processor that implements the entire SimpleRisc ISA. 2. Our processor is broadly divided into five stages: IF, OF, EX, MA, and RW. 3. The data path contains state elements (such as registers), arithmetic units, logical units, and multiplexers to choose the right set of inputs for each functional unit. 4. The multiplexers are controlled by control signals generated by the control unit.