9.6.2 Microinstructions

Let us look at the life cycle of a regular program instruction. The first step is to fetch the contents of the instruction from the instruction memory. Let us introduce a microinstruction to read the contents of the instruction from the instruction memory and place it in the IR  . Let us call it mloadIR. Note that we will add the prefix  (  for micro) to every microinstruction. This is to denote the fact that it is a microinstruction, and differentiate it from regular program instructions.

Once, we have loaded the instruction register, it automatically sends the contents to all the subunits in the decode unit, and they extract the appropriate bit fields, and save them in the decode registers –  ,  , rs1, rs2, immx, and branchT arget. We envision an mdecode instruction in the 0-address format that makes the  control unit wait for 1 cycle. In this cycle, all the decode registers get populated.

Note that these two steps (mloadIR and mdecode) are common for all program instructions. After this, we need to load the microinstructions for the specific program instruction. This is achieved through an mswitch instruction that instructs the µcontrol unit to jump to the appropriate location in the microinstruction memory, and begins executing microinstructions starting from that location.

Now, the processing of the instruction can start. The aim here is to use as few microinstructions as possible. We want to keep the microassembly interface very simple. Let us first introduce the mmov instruction that moves data from the source register to a destination register. Additionally, it can set the arguments of the unit corresponding to the destination register. We thus introduce a 2-address and 3-address format of the mmov instruction. The 3-address format contains the arguments (args) of the unit corresponding to the destination register, as shown below.

We sometimes face the need to load constants into registers. Hence, we introduce the mmovi instruction that loads a constant into a register.

We need an madd instruction because we need to increment the values of registers such as the  . Instead of using the main ALU, we can have a small adder as a part of the  control unit. We refer to this as the  adder. Here, there is a tradeoff to make. Do we need an add instruction that adds two registers, and saves it in another register? At the microinstruction level, this is seldom required. We definitely do not require this instruction to implement the SimpleRisc instruction set. Hence, we do not see a reason to include this microinstruction. If there is ever a need to have one such microinstruction, then we can always use the main ALU in the data path to perform the addition. We thus introduce a simple add instruction in the 2-address format. It adds an immediate value to a register. The semantics of this instruction is shown below.

Here, the madd instruction adds imm to  , and saves the result in  . imm can be a positive or a negative number. We restrict it to a 12-bit number, because we do not need more bits in most cases. The range of the immediate is thus between -2048 and  .

Lastly, we need branch instructions. We need both conditional branches, and unconditional branches. We thus introduce two new microinstructions – mb (branch) and mbeq (branch if the arguments are equal). The mb microinstruction takes a single argument, which is the address of the target microinstruction (or its label while writing microassembly code). We use the PC-direct addressing mode here as compared to the PC-relative addressing mode because, we expect the total number of microinstructions to be small. Secondly, if we would have use a PC-relative addressing mode, then we would have required an extra adder in our data path to add the offset to the PC. The SimpleRisc instruction set allocates 5 bits for the opcode. This means that at the most we can have 32 instructions in our instruction set. Let us assume that in the worst case, an instruction translates to 20 microinstructions. We would thus need to store 640 microinstructions. We can thus allocate 10 bits for the specifying the address of the microinstruction and our µpc (micro-PC) can also be 10 bits wide. This means that at the most we can support a total of 1024 microinstructions. This is much more than what we actually require. However, it is not a bad idea to over design hardware because it cannot be changed later. Note that in the microinstruction memory, the address refers to the index of the microinstruction (not to the starting address of the first byte).

The mbeq instruction requires three operands. The first operand is a register, the second operand is an immediate, and the third operand is the address(label) of a microinstruction. If the value contained in the register is equal to the immediate operand, then the microPC jumps to the microinstruction specified by the third operand. Otherwise, the next microinstruction in sequence is executed.

To summarize, Table 9.8 shows the 8 microinstructions that we have described in this section. We have a compact list of 8 microinstructions, and thus we can encode each microinstruction using just 3 bits.