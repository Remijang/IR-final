9.9.2 Further Reading

Processor design is very heavily studied in courses on computer architecture. Readers should first start with Chapter 10 that discusses pipelining. Chapter 10 is a sequel to the current chapter. The reader can then take a look at the “Further Reading” section (Section 10.12.2) in Chapter 10. In general, for basic processor design, the reader can also consult other books on computer architecture [Mano, 2007, Stallings, 2010, Henessey and Patterson, 2010] to get a different perspective. The books by Morris Mano [Mano, 2007], and Carl Hamacher [Hamacher et al., 2001] consider different flavors of microprogramming, and define their own semantics. If the reader is interested in the history of microprogramming per se, then she can consult books dedicated to the design and history of microprogramming [Carter, 1995, Husson, 1970]. The PTLSim [Yourst, 2007] simulator translates x86 instructions into micro-instructions, and simulates these microinstructions on a data path similar to that of commercial processors. Readers can take a look at the code of this simulator, and appreciate the nuances of processing and executing microinstructions.

Exercises

Hardwired Processor Design

Ex. 1 — We have divided a SimpleRisc processor into 5 distinct units. List them, and describe their functions.   
Ex. 2 — Explain the terms – data path and control path?   
Ex. 3 — How does having a lesser number of instruction formats help in the process of decoding an instruction?   
Ex. 4 — Draw the circuit for calculating the value of the 32-bit immediate, from the first 18 bits of the instruction. Take the modifiers into account.   
Ex. 5 — Why is it necessary for the register file in our SimpleRisc processor to have 2 read ports, and 1 write port?

Ex. 6 — Why do we need 2 multiplexers in the OF stage of the processor? What are their functions?

Ex. 7 — Let us propose to compute the branch outcome and target in the OF stage. Describe the design of the OF stage with this functionality.

\* Ex. 8 — For the ALU we use a multiplexer with numerous inputs. How can we implement this multiplexer with transmission gates? (show a circuit diagram, and explain why your idea will work)

Ex. 9 — Draw a circuit for implementing the cmp instruction. It should show the circuit for subtraction, and the logic for updating the flags.

Ex. 10 — How do we implement the call instruction in our processor?

Ex. 11 — Draw the circuit diagram for computing the isW b signal.

Ex. 12 — Why do we use the isAdd control signal for the load, and store instructions also?

Microprogramming

Ex. 13 — Compare a hardwired control unit and a microprogrammed control unit.

Ex. 14 — Draw the block diagram of a microprogrammed processor.

Ex. 15 — Why do we need the mswitch instruction?

Ex. 16 — Describe the microcode implementation of the load and store instructions.

Ex. 17 — Write a program in microassembly to check if a number in register  is a perfect square. Save the Boolean result in register, r0.

Ex. 18 — Write a program in microassembly to check if the value in register  is a palindrome. A palindrome reads the same from both sides. For example, the 8-bit number, 11011011 is a palindrome. Save the Boolean result in register, r0.

\* Ex. 19 — Write a program in microassembly to check if the value in register  can be expressed as a sum of two cubes in two different ways. For example, 1729, is one such number.  . Save the Boolean result in register, r0.

Ex. 20 — Outline the design of the shared bus, and microprogrammed data path. Explain the functionalities of each of its components.

Ex. 21 — Draw a detailed diagram of the  control unit along with the transfer multiplexer in a vertically microprogrammed processor.

Ex. 22 — Draw a detailed diagram of the  control unit along with the transfer multiplexer in a horizontally microprogrammed processor.

Ex. 23 — Compare the trade-offs between horizontal and vertical microprogramming.

Design Problems

Ex. 24 — Implement the hardwired SimpleRisc processor using Logisim, which is an educational tool for designing and simulating digital circuits. It is freely available at http: //ozark.hendrix.edu/\~burch/logisim. Try to support all the instructions, and the modifiers.

Ex. 25 — Now, try to implement a horizontally microprogrammed processor using Logisim.   
This project has two parts.   
a)Write a microassembler that can translate microassembly instructions to their machine encodings. Use this microassembler to generate the microcode for all the instructions in the SimpleRisc ISA.   
b)Create a data path and control path in Logisim for a horizontally microprogrammed processor. This processor should be able to directly execute the code generated by the microassembler.   
c)Run regular SimpleRisc programs on this processor.   
d)Implement custom SimpleRisc instructions such as multiply-add (  ), or instructions to find the square of a number on this processor.

Ex. 26 — Implement the basic hardwired processor in a high-level description language such as VHDL. You can use the freely available open source tool GNU HDL (http://gna.org/ projects/ghdl/) to implement and simulate your circuit.