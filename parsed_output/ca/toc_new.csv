chapter,section,page,json_idx
1,Introduction to Computer Architecture,13,63
1.1,What is a Computer?,14,71
1.2,Structure of a Typical Desktop Computer,16,87
1.3,Computers are Dumb Machines,17,94
1.4,The Language of Instructions,18,103
1.5,Instruction Set Design,20,111
1.5.1,Complete - The ISA should be able to Implement all User Programs,20,113
1.5.2,Concise – Limited Size of the Instruction Set,20,116
1.5.3,Generic – Instructions should Capture the Common Case,20,118
1.5.4,Simple – Instructions should be Simple,21,122
1.6,How to Ensure that an ISA is Complete?,22,131
1.6.1,Towards a Universal ISA\*,22,136
1.6.2,Turing Machine\*,23,143
1.6.3,Universal Turing Machine\*,27,168
1.6.4,A Modified Universal Turing Machine\*,28,183
1.6.5,Single Instruction ISA\*,30,197
1.6.6,Multiple Instruction ISA\*,31,206
1.6.7,Summary of Theoretical Results,32,215
1.7,Design of Practical Machines,34,227
1.7.1,Harvard Architecture,34,229
1.7.2,Von Neumann Architecture,34,233
1.7.3,Towards a Modern Machine with Registers and Stacks,36,244
1.8,The Road Ahead,38,264
1.8.1,Representing Information,39,269
1.8.2,Processing Information,40,277
1.8.3,Processing More Information,41,281
1.9,Summary and Further Reading,41,286
1.9.1,Summary,41,287
1.9.2,Further Reading,42,291
I,Architecture: Software Interface,45,313
2,The Language of Bits,47,314
2.1,Logical Operations,48,324
2.1.1,Basic Operators,49,331
2.1.2,Derived Operators,50,341
2.1.3,Boolean Algebra,50,347
2.1.4,De Morgan’s Laws,52,363
2.1.5,Logic Gates,52,376
2.1.6,Implementing Boolean Functions,53,382
2.1.7,The Road Ahead,56,408
2.2,Positive Integers,57,413
2.2.1,Ancient Number Systems,57,414
2.2.2,Binary Number System,59,427
2.2.3,Adding Binary Numbers,61,449
2.2.4,Sizes of Integers,63,461
2.3,Negative Integers,65,474
2.3.1,Sign-Magnitude-Based Representation,65,477
2.3.2,The 1’s Complement Approach,65,483
2.3.3,Bias-Based Approach,66,491
2.3.4,The 2’s Complement Method,67,499
2.4,Floating Point Numbers,74,566
2.4.1,Fixed Point Numbers,74,569
2.4.2,Generic Form of Floating Point Numbers,74,572
2.4.3,IEEE 754 Format for Representing Floating Point Numbers,77,599
2.4.4,Denormal Numbers,79,622
2.4.5,Double Precision Numbers,80,635
2.4.6,Floating Point Mathematics,81,641
2.5,Strings,82,649
2.5.1,ASCII Format,82,651
2.5.2,UTF-8,82,655
2.5.3,UTF-16 and UTF-32,83,660
2.6,Summary and Further Reading,84,662
2.6.1,Summary,84,663
2.6.2,Further Reading,85,685
3,Assembly Language,91,738
3.1,Why Assembly Language,91,740
3.1.1,Software Developer’s Perspective,91,741
3.1.2,Hardware Designer’s Perspective,95,769
3.2,The Basics of Assembly Language,96,773
3.2.1,Machine Model,96,774
3.2.2,View of Memory,97,784
3.2.3,Assembly Language Syntax,99,807
3.2.4,Types of Instructions,103,838
3.2.5,Types of Operands,104,854
3.3,SimpleRisc,107,892
3.3.1,Different Instruction Sets,107,895
3.3.2,Model of the SimpleRisc Machine,108,900
3.3.3,Register Transfer Instruction – mov,108,903
3.3.4,Arithmetic Instructions,108,906
3.3.5,Logical Instructions,110,917
3.3.6,"Shift Instructions – lsl, lsr, asr",110,924
3.3.7,Data Transfer Instructions: ld and st,111,928
3.3.8,Unconditional Branch Instructions,111,933
3.3.9,Conditional Branch Instructions,112,940
3.3.10,Functions,114,954
3.3.11,Function Call/Return Instructions,121,1012
3.3.12,The nop Instruction,123,1033
3.3.13,Modifiers,124,1038
3.3.14,Encoding the SimpleRisc Instruction Set,125,1050
3.4,Summary and Further Reading,133,1111
3.4.1,Summary,133,1112
3.4.2,Further Reading,135,1128
4,ARM R⃝ Assembly Language,139,1158
4.1,The ARM $\textsuperscript { \textregistered }$ Machine Model,139,1158
4.2,Basic Assembly Instructions,140,1166
4.2.1,Simple Data Processing Instructions,140,1167
4.2.2,Advanced Data-Processing Instructions,143,1203
4.2.3,Compare Instructions,146,1231
4.2.4,Instructions that Set CPSR Flags – The ‘S’ Suffix,147,1242
4.2.5,Data Processing Instructions that use CPSR Flags,147,1244
4.2.6,Simple Branch Instructions,148,1259
4.2.7,Branch and Link Instruction,150,1275
4.2.8,Conditional Instructions,152,1289
4.2.9,Load-Store Instructions,155,1306
4.3,Advanced Features,157,1329
4.3.1,Arrays,158,1332
4.3.2,Functions,160,1359
4.4,Encoding the Instruction Set,163,1387
4.4.1,Data Processing Instructions,163,1394
4.4.2,Load-Store Instructions,167,1423
4.4.3,Branch Instructions,168,1432
4.5,Summary and Further Reading,169,1436
4.5.1,Summary,169,1437
4.5.2,Further Reading,170,1454
5,x86 Assembly Language,175,1496
5.1,Overview of the x86 Family of Assembly Languages,175,1498
5.1.1,Brief History,175,1499
5.1.2,Main Features of the x86 ISA,176,1504
5.2,x86 Machine Model,177,1510
5.2.1,Integer Registers,177,1511
5.2.2,Floating Point Registers,179,1521
5.2.3,View of Memory,179,1525
5.2.4,Addressing Modes,182,1546
5.2.5,x86 Assembly Language,184,1563
5.3,Integer Instructions,185,1572
5.3.1,Data Transfer Instructions,185,1573
5.3.2,ALU Instructions,189,1616
5.3.3,Branch/ Function Call Instructions,195,1673
5.3.4,Advanced Memory Instructions,203,1726
5.4,Floating Point Instructions,207,1762
5.4.1,Data Transfer Instructions,208,1767
5.4.2,Arithmetic Instructions,210,1787
5.4.3,Instructions for Special Functions,211,1801
5.4.4,Compare Instruction,212,1808
5.4.5,Stack Cleanup Instructions,214,1819
5.5,Encoding the x86 ISA,214,1822
5.5.1,High Level View of x86 Instruction Encoding,215,1824
5.6,Summary and Further Reading,218,1854
5.6.1,Summary,218,1855
5.6.2,Further Reading,219,1860
6,RISC-V Assembly Language,225,1911
6.1,RISC-V Machine Model,226,1919
6.1.1,RISC-V Base ISAs and Extensions,226,1920
6.1.2,View of Registers,228,1938
6.2,Integer Instructions,229,1943
6.2.1,Moving Values to Registers,229,1945
6.2.2,Add and Subtract Instructions,231,1959
6.2.3,Multiplication and Division Instructions,232,1974
6.2.4,Logical and Shift Instructions,233,1992
6.3,Control Transfer and Memory Instructions,235,2008
6.3.1,Conditional Branches,235,2009
6.3.2,Unconditional Branches,239,2051
6.3.3,Load and Store Instructions,241,2065
6.4,Floating Point Instructions,245,2097
6.4.1,View of Registers,245,2099
6.4.2,Load and Store Instructions,247,2114
6.4.3,Floating Point Arithmetic Instructions,248,2123
6.4.4,Floating Point Conversion Instructions,249,2132
6.4.5,Floating Point Comparison Instructions,250,2141
6.5,Instruction Encoding,251,2147
6.5.1,Arithmetic and Data Transfer Instructions,251,2148
6.5.2,Control Flow Instructions,252,2160
6.5.3,Floating Point Instructions,254,2168
6.6,Summary and Further Reading,255,2178
6.6.1,Summary,255,2179
6.6.2,Further Reading,257,2185
II,Organization: Processor Design,261,2208
7,"Logic Gates, Registers, and Memories",263,2209
7.1,Silicon-Based Transistors,264,2218
7.1.1,Doping,265,2225
7.1.2,P-N Junction,266,2232
7.1.3,NMOS Transistor,267,2239
7.1.4,PMOS Transistor,268,2246
7.1.5,A Basic CMOS-Based Inverter,268,2249
7.1.6,NAND and NOR Gates,269,2254
7.2,Combinational Logic,271,2264
7.2.1,XOR Gate,271,2265
7.2.2,Decoder,272,2271
7.2.3,Multiplexer,272,2277
7.2.4,Demultiplexer,274,2288
7.2.5,Encoder,274,2291
7.2.6,Priority Encoder,276,2300
7.3,Sequential Logic,277,2310
7.3.1,SR Latch,277,2314
7.3.2,The Clock,279,2324
7.3.3,Clocked SR Latch,280,2336
7.3.4,Edge Sensitive SR Flip-flop,281,2346
7.3.5,JK Flip-flop,282,2353
7.3.6,D Flip-flop,283,2361
7.3.7,Master-slave D Flip-flop,283,2365
7.3.8,Metastability,284,2370
7.3.9,Registers,285,2375
7.4,Memories,286,2382
7.4.1,Static RAM (SRAM),286,2383
7.4.2,Content Addressable Memory (CAM),289,2401
7.4.3,Dynamic RAM (DRAM),291,2410
7.4.4,Read Only Memory (ROM),293,2423
7.4.5,Programmable Logic Arrays,295,2434
7.5,Summary and Further Reading,299,2459
7.5.1,Summary,299,2460
7.5.2,Further Reading,300,2463
8,Computer Arithmetic,305,2499
8.1,Addition,305,2502
8.1.1,Addition of Two 1-bit Numbers,305,2503
8.1.2,Addition of Three 1-bit Numbers,306,2515
8.1.3,Ripple Carry Adder,309,2526
8.1.4,Carry Select Adder,313,2550
8.1.5,Carry Lookahead Adder,314,2562
8.2,Multiplication,319,2609
8.2.1,Overview,319,2610
8.2.2,Iterative Multiplier,320,2620
8.2.3,Booth Multiplier,324,2642
8.2.4,An $O ( l o g ( n ) ^ { 2 } )$ Time Algorithm,330,2679
8.2.5,Wallace Tree Multiplier,331,2686
8.3,Division,333,2700
8.3.1,Overview,333,2701
8.3.2,Restoring Division,334,2714
8.3.3,Non-Restoring Division,338,2742
8.4,Floating Point Addition and Subtraction,341,2761
8.4.1,Simple Addition with Same Signs,342,2766
8.4.2,Rounding,344,2782
8.4.3,Implementing Rounding,345,2797
8.4.4,Addition of Numbers with Opposite Signs,346,2805
8.4.5,Generic Algorithm for Adding Floating Point Numbers,347,2812
8.5,Multiplication of Floating Point Numbers,347,2815
8.6,Division of Floating Point Numbers,349,2822
8.6.1,Simple Division,349,2823
8.6.2,Goldschmidt Division,349,2828
8.6.3,Division Using the Newton-Raphson Method,350,2838
8.7,Summary and Further Reading,353,2855
8.7.1,Summary,353,2856
8.7.2,Further Reading,354,2878
9,Processor Design,359,2928
9.1,Design of a Basic Processor,359,2930
9.1.1,Overview,359,2931
9.2,Units in a Processor,361,2944
9.2.1,Instruction Fetch – Fetch Unit,361,2945
9.2.2,Data Path and Control Path,363,2958
9.2.3,Operand Fetch Unit,364,2967
9.2.4,Execute Unit,369,2994
9.2.5,Memory Access Unit,372,3015
9.2.6,Register Writeback Unit,374,3025
9.2.7,The Data Path,375,3030
9.3,The Control Unit,375,3036
9.4,Microprogram-Based Processor,379,3051
9.5,Microprogrammed Data Path,381,3065
9.5.1,Fetch Unit,382,3071
9.5.2,Decode Unit,382,3075
9.5.3,Register File,383,3082
9.5.4,ALU,384,3088
9.5.5,Memory Unit,385,3091
9.5.6,Overview of the Data Path,385,3094
9.6,Microassembly Language,386,3102
9.6.1,Machine Model,386,3103
9.6.2,Microinstructions,386,3107
9.6.3,Implementing Instructions in the Microassembly Language,390,3129
9.6.4,3-Address Format ALU Instructions,391,3137
9.6.5,2-Address Format ALU Instructions,393,3154
9.6.6,The nop Instruction,395,3165
9.6.7,ld and st instructions,395,3167
9.6.8,Branch Instructions,396,3172
9.7,Shared Bus and Control Signals,401,3208
9.7.1,Control Signals,402,3215
9.7.2,Functional Unit Arguments,402,3219
9.8,The Microcontrol Unit,403,3222
9.8.1,Vertical Microprogramming,403,3224
9.8.2,Horizontal Microprogramming,405,3233
9.8.3,Trade-offs between Horizontal and Vertical Microprogramming,406,3241
9.9,Summary and Further Reading,407,3246
9.9.1,Summary,407,3247
9.9.2,Further Reading,408,3258
10,Principles of Pipelining,411,3287
10.1,A Pipelined Processor,411,3288
10.1.1,The Notion of Pipelining,411,3293
10.1.2,Overview of Pipelining,412,3299
10.1.3,Performance Benefits,413,3308
10.2,Design of a Simple Pipeline,414,3316
10.2.1,Splitting the Data Path,414,3318
10.2.2,Timing,415,3322
10.2.3,The Instruction Packet,416,3329
10.3,Pipeline Stages,417,3333
10.3.1,IF Stage,417,3334
10.3.2,OF Stage,417,3337
10.3.3,EX Stage,418,3342
10.3.4,MA Stage,419,3347
10.3.5,RW Stage,419,3351
10.3.6,Putting it All Together,420,3354
10.4,Pipeline Hazards,420,3357
10.4.1,The Pipeline Diagram,420,3359
10.4.2,Data Hazards,423,3377
10.4.3,Control Hazards,425,3395
10.4.4,Structural Hazards,427,3407
10.5,Solutions in Software,428,3417
10.5.1,RAW Hazards,428,3418
10.5.2,Control Hazards,429,3429
10.6,Pipeline with Interlocks,431,3444
10.6.1,A Conceptual Look at a Pipeline with Interlocks,432,3455
10.6.2,Ensuring the Data-Lock Condition,435,3474
10.6.3,Ensuring the Branch-Lock condition,438,3484
10.7,Pipeline with Forwarding,438,3490
10.7.1,Basic Concepts,438,3491
10.7.2,Forwarding Paths in a Pipeline,441,3506
10.7.3,Data Hazards with Forwarding,444,3524
10.7.4,Implementation of a Pipeline with Forwarding,445,3535
10.7.5,Forwarding Conditions,450,3561
10.8,Support for Interrupts/ Exceptions\*,455,3591
10.8.1,Interrupts,455,3593
10.8.2,Exceptions,456,3598
10.8.3,Precise Exceptions,456,3602
10.8.4,Saving and Restoring Program State,459,3624
10.8.5,SimpleRisc Assembly Code of an Interrupt Handler,463,3658
10.8.6,Processor with Support for Exceptions,463,3660
10.9,Performance Metrics,463,3662
10.9.1,The Performance Equation,463,3663
10.9.2,Performance of an Ideal Pipelined Processor,467,3683
10.9.3,Performance of a Non-Ideal Pipeline,470,3705
10.9.4,Performance of a Suite of Programs,473,3749
10.9.5,"Inter-Relationship between Performance, the Compiler, Architecture, and Technology",474,3761
10.10,Power and Temperature Issues,477,3788
10.10.1,Overview,477,3789
10.10.2,Dynamic Power,479,3799
10.10.3,Leakage Power,481,3820
10.10.4,Modeling Temperature\*,482,3834
10.10.5,The $E D ^ { 2 }$ Metric,483,3840
10.11,Advanced Techniques\*,485,3853
10.11.1,Branch Prediction,485,3858
10.11.2,Multiple Issue In-Order Pipeline,489,3883
10.11.3,EPIC and VLIW Processors,491,3898
10.11.4,Out-of-Order Pipelines,492,3906
10.12,Summary and Further Reading,495,3924
10.12.1,Summary,495,3925
10.12.2,Further Reading,497,3937
III,Organization: System Design,503,4002
11,The Memory System,505,4003
11.1,Overview,506,4009
11.1.1,Need for a Fast Memory System,506,4010
11.1.2,Memory Access Patterns,507,4019
11.1.3,Temporal and Spatial Locality of Instruction Accesses,508,4029
11.1.4,Characterizing Temporal Locality,509,4035
11.1.5,Characterizing Spatial Locality,511,4047
11.1.6,Utilizing Spatial and Temporal Locality,511,4054
11.1.7,Exploiting Temporal Locality – Hierarchical Memory System,512,4059
11.1.8,Exploiting Spatial Locality – Cache Blocks,515,4083
11.2,Caches,517,4098
11.2.1,Overview of a Basic Cache,517,4099
11.2.2,Cache Lookup and Cache Design,518,4110
11.2.3,Data read and data write Operations,526,4160
11.2.4,The insert Operation,527,4173
11.2.5,The replace Operation,528,4180
11.2.6,The evict Operation,530,4199
11.2.7,Putting all the Pieces Together,530,4201
11.3,The Memory System,532,4211
11.3.1,Mathematical Model of the Memory System,533,4219
11.3.2,Cache Misses,535,4238
11.3.3,Reduction of Hit Time and Miss Penalty,537,4260
11.3.4,Summary of Memory System Optimization Techniques,538,4268
11.4,Virtual Memory,539,4272
11.4.1,Process – A Running Instance of a Program,540,4276
11.4.2,The “Overlap” and “Size” Problems,546,4315
11.4.3,Implementation of Virtual Memory with Paging,546,4320
11.4.4,Swap Space,552,4361
11.4.5,Memory Management Unit (MMU),553,4368
11.4.6,Advanced Features of the Paging System,555,4380
11.5,Summary and Further Reading,556,4389
11.5.1,Summary,556,4390
11.5.2,Further Reading,558,4402
12,Multiprocessor Systems,565,4454
12.1,Background,567,4468
12.1.1,Moore’s Law,568,4476
12.1.2,Implications of the Moore’s Law,569,4482
12.2,Software for Multiprocessor Systems,570,4488
12.2.1,Strong and Loosely Coupled Multiprocessing,570,4489
12.2.2,Shared Memory vs Message Passing,571,4501
12.2.3,Amdahl’s Law,576,4532
12.3,Design Space of Multiprocessors,578,4543
12.4,MIMD Multiprocessors,579,4554
12.4.1,Logical Point of View,579,4557
12.4.2,Coherence,581,4564
12.4.3,Memory Consistency,583,4583
12.4.4,Physical View of Memory,593,4646
12.4.5,Shared Caches,596,4664
12.4.6,Coherent Private Caches,596,4669
12.4.7,Implementing a Memory Consistency Model\*,603,4714
12.4.8,Multithreaded Processors,608,4762
12.5,SIMD Multiprocessors,612,4789
12.5.1,SIMD – Vector Processors,613,4795
12.5.2,Software Interface,614,4805
12.5.3,A Practical Example using SSE Instructions,616,4819
12.5.4,Predicated Instructions,618,4834
12.5.5,Design of a Vector Processor,620,4853
12.6,Interconnection Networks,620,4856
12.6.1,Overview,620,4857
12.6.2,Bisection Bandwidth and Network Diameter,622,4866
12.6.3,Network Topologies,623,4876
12.7,Summary and Further Reading,630,4919
12.7.1,Summary,630,4920
12.7.2,Further Reading,633,4937
13,I/O and Storage Devices,641,5032
13.1,I/O System – Overview,642,5040
13.1.1,Overview,642,5041
13.1.2,Requirements of the I/O System,645,5059
13.1.3,Design of the I/O System,646,5068
13.1.4,Layers in the I/O System,649,5093
13.2,Physical Layer – Transmission Sublayer,650,5101
13.2.1,Single Ended Signaling,652,5111
13.2.2,Low Voltage Differential Signaling (LVDS),653,5117
13.2.3,Transmission of Multiple Bits,654,5121
13.2.4,Return to Zero (RZ) Protocols,655,5127
13.2.5,Manchester Encoding,656,5137
13.2.6,Non Return to Zero (NRZ) Protocol,657,5146
13.2.7,Non Return to Zero (NRZI) Inverted Protocol,658,5151
13.3,Physical Layer – Synchronization Sublayer,659,5154
13.3.1,Synchronous Buses,659,5157
13.3.2,Source Synchronous Bus\*,662,5179
13.3.3,Asynchronous Buses,663,5184
13.4,Data Link Layer,667,5211
13.4.1,Framing and Buffering,667,5215
13.4.2,Error Detection and Correction,668,5222
13.4.3,Arbitration,674,5272
13.4.4,Transaction-Oriented Buses,677,5289
13.4.5,Split Transaction Buses,679,5303
13.5,Network Layer,680,5307
13.5.1,I/O Port Addressing,680,5310
13.5.2,Memory-Mapped Addressing,683,5331
13.6,Protocol Layer,684,5339
13.6.1,Polling,685,5345
13.6.2,Interrupts,686,5353
13.6.3,DMA,687,5361
13.7,Case Studies – I/O Protocols,688,5369
13.7.1,PCI Express $\textsuperscript { \textregistered }$,689,5371
13.7.2,SATA,691,5384
13.7.3,SCSI and SAS,691,5390
13.7.4,USB,694,5405
13.7.5,FireWire Protocol,697,5434
13.8,Storage,699,5450
13.8.1,Hard Disks,701,5462
13.8.2,RAID Arrays,707,5507
13.8.3,"Optical Disks – CD, DVD, Blu-ray",711,5538
13.8.4,Flash Memory,715,5567
13.9,Summary and Further Reading,721,5605
13.9.1,Summary,721,5606
13.9.2,Further Reading,724,5628
IV,Appendix,729,5672
A,Case Studies of Real Processors,731,5673
A.1,ARM Processors,731,5675
A.1.1,ARM Cortex-M3,732,5681
A.1.2,ARM Cortex-A8,734,5696
A.1.3,ARM Cortex-A15,736,5709
A.2,AMD Processors,739,5725
A.2.1,AMD Bobcat,739,5727
A.2.2,AMD Bulldozer,741,5739
A.3,Intel Processors,743,5753
A.3.1,Intel Atom,744,5755
A.3.2,Intel Sandy Bridge,746,5769
B,Graphics Processors,751,5787
B.1,Overview,751,5787
B.1.1,Graphics Applications,752,5791
B.1.2,Graphics Pipeline,753,5797
B.1.3,Fusion of High Performance Computing and Graphics Computing,754,5805
B.2,NVIDIA Tesla Architecture,754,5810
B.2.1,Work Distribution,755,5814
B.2.2,GPU Compute Engines,756,5819
B.2.3,"Interconnection Network, DRAM Modules, L2 Caches, and ROPs",756,5821
B.3,Streaming Multiprocessors (SMs),757,5824
B.4,Computation on a GPU,758,5832
B.5,CUDA Programs,760,5842
