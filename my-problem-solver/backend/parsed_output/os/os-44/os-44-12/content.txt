44.12 Summary
Flash-based SSDs are becoming a common presence in laptops, desktops, and servers inside the datacenters that power the world’s economy. Thus, you should probably know something about them, right?  
Here’s the bad news: this chapter (like many in this book) is just the first step in understanding the state of the art. Some places to get some more information about the raw technology include research on actual device performance (such as that by Chen et al. $\left[ \mathrm { C K + 0 9 } \right]$ and Grupp et al. $\left[ { \cal G } { \bar { \cal C } } { + } 0 9 \right]$ ), issues in FTL design (including works by Agrawal et al. $\scriptstyle [ { \mathrm { A } } + 0 8 ] ,$ , Gupta et al. $\left[ \mathrm { G Y + 0 9 } \right]$ , Huang et al. $[ \breve { \mathrm { H } } \cdot 1 4 ]$ , Kim et al. $[ \mathsf { K K } + 0 2 ] ,$ , Lee et al. $[ \bar { \mathrm { L } } + 0 7 ] ,$ and Zhang et al. $[ Z + 1 2 ] ,$ ), and even distributed systems comprised of flash (including Gordon $\left[ \mathrm { C G + 0 9 } \right]$ and CORFU $\left[ { \mathrm { B } } { + } 1 2 \right]$ ). And, if we may say so, a really good overview of all the things you need to do to extract high performance from an SSD can be found in a paper on the “unwritten contract” $\mathrm { [ H K + 1 7 ] }$ .  
Don’t just read academic papers; also read about recent advances in the popular press (e.g., [V12]). Therein you’ll learn more practical (but still useful) information, such as Samsung’s use of both TLC and SLC cells within the same SSD to maximize performance (SLC can buffer writes quickly) as well as capacity (TLC can store more bits per cell). And this is, as they say, just the tip of the iceberg. Dive in and learn more about this “iceberg” of research on your own, perhaps starting with Ma et al.’s excellent (and recent) survey $\dot { [ \mathrm { M } + 1 4 ] }$ . Be careful though; icebergs can sink even the mightiest of ships [W15].  
ASIDE: KEY SSD TERMS 
• A flash chip consists of many banks, each of which is organized into erase blocks (sometimes just called blocks). Each block is further subdivided into some number of pages. 
• Blocks are large (128KB–2MB) and contain many pages, which are relatively small (1KB–8KB). 
• To read from flash, issue a read command with an address and length; this allows a client to read one or more pages. Writing flash is more complex. First, the client must erase the entire block (which deletes all information within the block). Then, the client can program each page exactly once, thus completing the write. 
A new trim operation is useful to tell the device when a particular block (or range of blocks) is no longer needed. 
• Flash reliability is mostly determined by wear out; if a block is erased and programmed too often, it will become unusable. 
• A flash-based solid-state storage device (SSD) behaves as if it were a normal block-based read/write disk; by using a flash translation layer (FTL), it transforms reads and writes from a client into reads, erases, and programs to underlying flash chips. 
• Most FTLs are log-structured, which reduces the cost of writing by minimizing erase/program cycles. An in-memory translation layer tracks where logical writes were located within the physical medium. 
• One key problem with log-structured FTLs is the cost of garbage collection, which leads to write amplification. 
• Another problem is the size of the mapping table, which can become quite large. Using a hybrid mapping or just caching hot pieces of the FTL are possible remedies. 
• One last problem is wear leveling; the FTL must occasionally migrate data from blocks that are mostly read in order to ensure said blocks also receive their share of the erase/program load.  