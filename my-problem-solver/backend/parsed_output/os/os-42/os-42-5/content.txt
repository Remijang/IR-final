42.5 Summary
We have introduced the problem of crash consistency, and discussed various approaches to attacking this problem. The older approach of building a file system checker works but is likely too slow to recover on modern systems. Thus, many file systems now use journaling. Journaling reduces recovery time from O(size-of-the-disk-volume) to O(size-of-thelog), thus speeding recovery substantially after a crash and restart. For this reason, many modern file systems use journaling. We have also seen that journaling can come in many different forms; the most commonly used is ordered metadata journaling, which reduces the amount of traffic to the journal while still preserving reasonable consistency guarantees for both file system metadata and user data. In the end, strong guarantees on user data are probably one of the most important things to provide; oddly enough, as recent research has shown, this area remains a work in progress $[ \bar { \mathrm { P } } \bar { + } 1 4 ]$ .  
References 
[B07] “ZFS: The Last Word in File Systems” by Jeff Bonwick and Bill Moore. Available online: http://www.ostep.org/Citations/zfs_last.pdf. ZFS uses copy-on-write and journaling, actually, as in some cases, logging writes to disk will perform better. 
$[ C + 1 2 ]$ “Consistency Without Ordering” by Vijay Chidambaram, Tushar Sharma, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau. FAST ’12, San Jose, California. A recent paper of ours about a new form of crash consistency based on back pointers. Read it for the exciting details! $\left[ \mathsf { C } + 1 3 \right]$ “Optimistic Crash Consistency” by Vijay Chidambaram, Thanu S. Pillai, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau . SOSP ’13, Nemacolin Woodlands Resort, PA, November 2013. Our work on a more optimistic and higher performance journaling protocol. For workloads that call fsync() a lot, performance can be greatly improved. 
[GP94] “Metadata Update Performance in File Systems” by Gregory R. Ganger and Yale N. Patt. OSDI ${ ' 9 4 }$ . A clever paper about using careful ordering of writes as the main way to achieve consistency. Implemented later in BSD-based systems. 
$\left[ \mathsf { G } \star 0 8 \right]$ “SQCK: A Declarative File System Checker” by Haryadi S. Gunawi, Abhishek Rajimwale, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau. OSDI ’08, San Diego, California. Our own paper on a new and better way to build a file system checker using SQL queries. We also show some problems with the existing checker, finding numerous bugs and odd behaviors, a direct result of the complexity of fsck. 
[H87] “Reimplementing the Cedar File System Using Logging and Group Commit” by Robert Hagmann. SOSP ’87, Austin, Texas, November 1987. The first work (that we know of) that applied write-ahead logging (a.k.a. journaling) to a file system. 
$\left[ \mathrm { M } \mathbf { + } 1 3 \right]$ “ffsck: The Fast File System Checker” by Ao Ma, Chris Dragga, Andrea C. ArpaciDusseau, Remzi H. Arpaci-Dusseau. FAST ’13, San Jose, California, February 2013. A recent paper of ours detailing how to make fsck an order of magnitude faster. Some of the ideas have already been incorporated into the BSD file system checker [MK96] and are deployed today. 
[MK96] “Fsck – The UNIX File System Check Program” by Marshall Kirk McKusick and T. J. Kowalski. Revised in 1996. Describes the first comprehensive file-system checking tool, the eponymous fsck. Written by some of the same people who brought you FFS. 
[MJLF84] “A Fast File System for UNIX” by Marshall K. McKusick, William N. Joy, Sam J. Leffler, Robert S. Fabry. ACM Transactions on Computing Systems, Volume 2:3, August 1984. You already know enough about FFS, right? But come on, it is OK to re-reference important papers. $\scriptstyle { [ { \mathrm { P } } + 1 4 ] }$ “All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-Consistent Applications” by Thanumalayan Sankaranarayana Pillai, Vijay Chidambaram, Ramnatthan Alagappan, Samer Al-Kiswany, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau. OSDI ’14, Broomfield, Colorado, October 2014. A paper in which we study what file systems guarantee after crashes, and show that applications expect something different, leading to all sorts of interesting problems. 
$[ \mathrm { P } \substack { + } 0 5 ]$ “IRON File Systems” by Vijayan Prabhakaran, Lakshmi N. Bairavasundaram, Nitin Agrawal, Haryadi S. Gunawi, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau. SOSP ${ ' 0 5 }$ , Brighton, England, October 2005. A paper mostly focused on studying how file systems react to disk failures. Towards the end, we introduce a transaction checksum to speed up logging, which was eventually adopted into Linux ext4. 
[PAA05] “Analysis and Evolution of Journaling File Systems” by Vijayan Prabhakaran, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau. USENIX ’05, Anaheim, California, April 2005. An early paper we wrote analyzing how journaling file systems work. 
$\left[ \scriptstyle { \mathrm { R + 1 1 } } \right]$ “Coerced Cache Eviction and Discreet-Mode Journaling” by Abhishek Rajimwale, Vijay Chidambaram, Deepak Ramamurthi, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau. DSN ’11, Hong Kong, China, June 2011. Our own paper on the problem of disks that buffer writes in a memory cache instead of forcing them to disk, even when explicitly told not to do that! Our solution to overcome this problem: if you want A to be written to disk before B, first write A, then send a lot of “dummy” writes to disk, hopefully causing A to be forced to disk to make room for them in the cache. A neat if impractical solution.  
[T98] “Journaling the Linux ext2fs File System” by Stephen C. Tweedie. The Fourth Annual Linux Expo, May 1998. Tweedie did much of the heavy lifting in adding journaling to the Linux ext2 file system; the result, not surprisingly, is called ext3. Some nice design decisions include the strong focus on backwards compatibility, e.g., you can just add a journaling file to an existing ext2 file system and then mount it as an ext3 file system.  
[T00] “EXT3, Journaling Filesystem” by Stephen Tweedie. Talk at the Ottawa Linux Symposium, July 2000. olstrans.sourceforge.net/release/OLS2000-ext3/OLS2000-ext3.html A transcript of a talk given by Tweedie on ext3.  
[T01] “The Linux ext2 File System” by Theodore Ts’o, June, 2001.. Available online here: http://e2fsprogs.sourceforge.net/ext2.html. A simple Linux file system based on the ideas found in FFS. For a while it was quite heavily used; now it is really just in the kernel as an example of a simple file system.  
OPERATINGSYSTEMS[VERSION 1.10]  
Homework (Simulation)
This section introduces fsck.py, a simple simulator you can use to better understand how file system corruptions can be detected (and potentially repaired). Please see the associated README for details on how to run the simulator.  
Questions

First, run fsck.py $- \mathtt { D }$ ; this flag turns off any corruption, and thus you can use it to generate a random file system, and see if you can determine which files and directories are in there. So, go ahead and do that! Use the $- \mathtt { p }$ flag to see if you were right. Try this for a few different randomly-generated file systems by setting the seed $( - s )$ to different values, like 1, 2, and 3.   
Now, let’s introduce a corruption. Run fsck.py $- \mathsf { S } \mathsf { \Omega } \perp \mathsf { \Omega }$ to start. Can you see what inconsistency is introduced? How would you fix it in a real file system repair tool? Use $- \mathtt { C }$ to check if you were right.   
Change the seed to $- \varsigma \ 3$ or $- \mathrm { ~ S ~ } \ 1 9$ ; which inconsistency do you see? Use $- \mathtt { C }$ to check your answer. What is different in these two cases?   
Change the seed to -S 5; which inconsistency do you see? How hard would it be to fix this problem in an automatic way? Use $- \mathtt { C }$ to check your answer. Then, introduce a similar inconsistency with $- S$ 38; is this harder/possible to detect? Finally, use $- \mathrm { ~ S ~ } ~ 6 4 2 ,$ ; is this inconsistency detectable? If so, how would you fix the file system?   
Change the seed to $- \mathrm { ~ S ~ } ~ 6$ or $- \mathrm { ~ S ~ } \ 1 3 .$ ; which inconsistency do you see? Use $- \mathtt { C }$ to check your answer. What is the difference across these two cases? What should the repair tool do when encountering such a situation?   
Change the seed to -S 9; which inconsistency do you see? Use $- \mathtt { C }$ to check your answer. Which piece of information should a checkand-repair tool trust in this case?   
Change the seed to $- s \ 1 5$ ; which inconsistency do you see? Use $- \mathtt { C }$ to check your answer. What can a repair tool do in this case? If no repair is possible, how much data is lost?   
Change the seed to $- \mathrm { ~ S ~ } \ 1 0 .$ ; which inconsistency do you see? Use $- \mathtt { C }$ to check your answer. Is there redundancy in the file system structure here that can help a repair?   
Change the seed to $- s \ 1 6$ and -S 20; which inconsistency do you see? Use $- \mathtt { C }$ to check your answer. How should the repair tool fix the problem?  
