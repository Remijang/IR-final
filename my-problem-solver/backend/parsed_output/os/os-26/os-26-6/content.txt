26.6 One More Problem: Waiting For Another
This chapter has set up the problem of concurrency as if only one type of interaction occurs between threads, that of accessing shared variables and the need to support atomicity for critical sections. As it turns out, there is another common interaction that arises, where one thread must wait for another to complete some action before it continues. This interaction arises, for example, when a process performs a disk I/O and is put to sleep; when the I/O completes, the process needs to be roused from its slumber so it can continue.  
Thus, in the coming chapters, we’ll be not only studying how to build support for synchronization primitives to support atomicity but also for mechanisms to support this type of sleeping/waking interaction that is common in multi-threaded programs. If this doesn’t make sense right now, that is OK! It will soon enough, when you read the chapter on condition variables. If it doesn’t by then, well, then it is less OK, and you should read that chapter again (and again) until it does make sense.  
OPERATINGSYSTEMS[VERSION 1.10]  
ASIDE: KEY CONCURRENCY TERMSCRITICAL SECTION, RACE CONDITION,INDETERMINATE, MUTUAL EXCLUSION  
These four terms are so central to concurrent code that we thought it worth while to call them out explicitly. See some of Dijkstra’s early work [D65,D68] for more details.  
• A critical section is a piece of code that accesses a shared resource, usually a variable or data structure. A race condition (or data race [NM92]) arises if multiple threads of execution enter the critical section at roughly the same time; both attempt to update the shared data structure, leading to a surprising (and perhaps undesirable) outcome. An indeterminate program consists of one or more race conditions; the output of the program varies from run to run, depending on which threads ran when. The outcome is thus not deterministic, something we usually expect from computer systems. To avoid these problems, threads should use some kind of mutual exclusion primitives; doing so guarantees that only a single thread ever enters a critical section, thus avoiding races, and resulting in deterministic program outputs.  