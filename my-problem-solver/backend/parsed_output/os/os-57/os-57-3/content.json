[
    {
        "type": "text",
        "text": "57.3 Public Key Authentication For Distributed Systems ",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "The public key doesn’t need to be secret, but we need to be sure it really belongs to our partner. If we have a face-to-face meeting, our partner can directly give us a public key in some form or another, in which case we can be pretty sure it’s the right one. That’s limiting, though, since we often interact with partners whom we never see face to face. For that matter, whose “face” belongs to Amazon2 or Google? ",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "Fortunately, we can use the fact that secrecy isn’t required to simply create a bunch of bits containing the public key. Anyone who gets a copy of the bits has the key. But how do they know for sure whose key it is? What if some other trusted party known to everyone who needs to authenticate our partner used their own public key to cryptographically sign that bunch of bits, verifying that they do indeed belong to our partner? If we could check that signature, we could then be sure that bunch of bits really does represent our partner’s public key, at least to the extent that we trust that third party who did the signature. ",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "This technique is how we actually authenticate web sites and many other entities on the Internet. Every time you browse the web or perform any other web-based activity, you use it. The signed bundle of bits is called a certificate. Essentially, it contains information about the party that owns the public key, the public key itself, and other information, such as an expiration date. The entire set of information, including the public key, is run through a cryptographic hash, and the result is encrypted with the trusted third party’s private key, digitally signing the certificate. If you obtain a copy of the certificate, and can check the signature, you can learn someone else’s public key, even if you have never met or had any direct interaction with them. In certain ways, it’s a beautiful technology that empowers the whole Internet. ",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "Let’s briefly go through an example, to solidify the concepts. Let’s say Frobazz Inc. wants to obtain a certificate for its public key, which is $\\dot { ~ } K F$ . Frobazz Inc. pays big bucks to Acmesign Co., a widely trusted company whose business it is to sell certificates, to obtain a certificate signed by AcmeSign. Such companies are commonly called Certificate Authorities, or CAs, since they create authoritative certificates trusted by many parties. Acmesign checks up on Frobazz Inc. to ensure that the people asking for the certificate actually are legitimate representatives of Frobazz. Acmesign then makes very, very sure that the public key it’s about to embed in a certificate actually is the one that Frobazz wants to use. Assuming it is, Acmesign runs a cryptographic hashing algorithm (perhaps SHA-3 which, unlike SHA-1, has not been cracked, as of 2020) on Frobazz’s name, public key $K F _ { ☉ }$ , and other information, producing hash $H F$ . Acmesign then encrypts $H F$ with its own private key, $P A ,$ producing digital signature $S F$ . Finally, Acmesign combines all the information used to produce $H F$ , plus Acmesign’s own identity and the signature $S F$ , into the certificate $C F _ { . }$ , which it hands over to Frobazz, presumably in exchange for money. Remember, $C F$ is just some bits. ",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "Now Frobazz Inc. wants to authenticate itself over the Internet to one of its customers. If the customer already has Frobazz’s public key, we can use public key authentication mechanisms directly. If the customer does not have the public key, Frobazz sends $C F$ to the customer. The customer examines the certificate, sees that it was generated by Acmesign using, say, SHA-3, and runs the same information that Acmesign hashed (all of which is in the certificate itself) through SHA-3, producing $H F ^ { \\prime }$ . Then the customer uses Acmesign’s public key to decrypt $S F$ (also in the ",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "OPERATINGSYSTEMS[VERSION 1.10]",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "certificate), obtaining $H F$ . If all is well, $H F$ equals $H F ^ { \\prime }$ , and now the customer knows that the public key in the certificate is indeed Frobazz’s. Public key-based authentication can proceed3. If the two hashes aren’t exactly the same, the customer knows that something fishy is going on and will not accept the certificate. ",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "There are some wonderful properties about this approach to learning public keys. First, note that the signing authority (Acmesign, in our example) did not need to participate in the process of the customer checking the certificate. In fact, Frobazz didn’t really, either. The customer can get the certificate from literally anywhere and obtain the same degree of assurance of its validity. Second, it only needs to be done once per customer. After obtaining the certificate and checking it, the customer has the public key that is needed. From that point onward, the customer can simply store it and use it. If, for whatever reason, it gets lost, the customer can either extract it again from the certificate (if that has been saved), or go through the process of obtaining the certificate again. Third, the customer had no need to trust the party claiming to be Frobazz until that identity had been proven by checking the certificate. The customer can proceed with caution until the certificate checks out. ",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Assuming you’ve been paying attention for the last few chapters, you should be saying to yourself, “now, wait a minute, isn’t there a chickenand-egg problem here?” We’ll learn Frobazz’s public key by getting a certificate for it. The certificate will be signed by Acmesign. We’ll check the signature by knowing Acmesign’s public key. But where did we get Acmesign’s key? We really hope you did have that head-scratching moment and asked yourself that question, because if you did, you understand the true nature of the Internet authentication problem. Ultimately, we’ve got to bootstrap it. You’ve got to somehow or other obtain a public key for somebody that you trust. Once you do, if it’s the right public key for the right kind of party, you can then obtain a lot of other public keys. But without something to start from, you can’t do much of anything. ",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Where do you get that primal public key? Most commonly, it comes in a piece of software you obtain and install. The one you use most often is probably your browser, which typically comes with the public keys for several hundred trusted authorities4. Whenever you go to a new web site that cares about security, it provides you with a certificate containing that site’s public key, and signed by one of those trusted authorities preconfigured into your browser. You use the pre-configured public key of that authority to verify that the certificate is indeed proper, after which you know the public key of that web site. From that point onward, you can use the web site’s public key to authenticate it. There are some serious caveats here (and some interesting approaches to addressing those caveats), but let’s put those aside for the moment. ",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "Anyone can create a certificate, not just those trusted CAs, either by getting one from someone whose business it is to issue certificates or simply by creating one from scratch, following a certificate standard (X.509 is the most commonly used certificate standard [I12]). The necessary requirement: the party being authenticated and the parties performing the authentication must all trust whoever created the certificate. If they don’t trust that party, why would they believe the certificate is correct? ",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "If you are building your own distributed system, you can create your own certificates from a machine you (and other participants in the system) trust and can handle the bootstrapping issue by carefully handinstalling the certificate signing machine’s public key wherever it needs to be. There are a number of existing software packages for creating certificates, and, as usual with critical cryptographic software, you’re better off using an existing, trusted implementation rather than coding up one of your own. One example you might want to look at is PGP (available in both supported commercial versions and compatible but less supported free versions) [P16], but there are others. If you are working with a fixed number of machines and you can distribute the public key by hand in some reasonable way, you can dispense entirely with certificates. Remember, the only point of a PK certificate is to distribute the public key, so if your public keys are already where they need to be, you don’t need certificates. ",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "OK, one way or another you’ve obtained the public key you need to authenticate some remote machine. Now what? Well, anything they send you encrypted with their private key will only decrypt with their public key, so anything that decrypts properly with the public key must have come from them, right? Yes, it must have come from them at some point, but it’s possible for an adversary to have made a copy of a legitimate message the site sent at some point in the past and then send it again it at some future date. Depending on exactly what’s going on, that could cause trouble, since you may take actions based on that message that the legitimate site did not ask for. So usually we take measures to ensure that we’re not being subjected to a replay attack. Such measures generally involve ensuring that each encrypted message contains unique information not in any other message. This feature is built in properly to standard cryptographic protocols, so if you follow our advice and use one of those, you will get protection from such replay attacks. If you insist on building your own cryptography, you’ll need to learn a good deal more about this issue and will have to apply that knowledge very carefully. Also, public key cryptography is expensive. We want to stop using it as soon as possible, but we also want to continue to get authentication guarantees. We’ll see how to do that when we discuss SSL and TLS. ",
        "page_idx": 5
    }
]