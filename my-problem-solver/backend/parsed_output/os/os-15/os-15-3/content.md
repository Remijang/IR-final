# 15.3 Dynamic (Hardware-based) Relocation  

To gain some understanding of hardware-based address translation, we’ll first discuss its first incarnation. Introduced in the first time-sharing machines of the late $1 9 5 0 ^ { \prime } \mathrm { s }$ is a simple idea referred to as base and bounds; the technique is also referred to as dynamic relocation; we’ll use both terms interchangeably [SS74].  

Specifically, we’ll need two hardware registers within each CPU: one is called the base register, and the other the bounds (sometimes called a limit register). This base-and-bounds pair is going to allow us to place the  

# ASIDE: SOFTWARE-BASED RELOCATION  

In the early days, before hardware support arose, some systems performed a crude form of relocation purely via software methods. The basic technique is referred to as static relocation, in which a piece of software known as the loader takes an executable that is about to be run and rewrites its addresses to the desired offset in physical memory.  

For example, if an instruction was a load from address 1000 into a register (e.g., movl 1000, %eax), and the address space of the program was loaded starting at address 3000 (and not 0, as the program thinks), the loader would rewrite the instruction to offset each address by 3000 (e.g., movl 4000, %eax). In this way, a simple static relocation of the process’s address space is achieved.  

However, static relocation has numerous problems. First and most importantly, it does not provide protection, as processes can generate bad addresses and thus illegally access other process’s or even OS memory; in general, hardware support is likely needed for true protection $\left[ { \mathrm { W L } } { \dot { + } } 9 3 \right]$ . Another negative is that once placed, it is difficult to later relocate an address space to another location [M65].  

address space anywhere we’d like in physical memory, and do so while ensuring that the process can only access its own address space.  

In this setup, each program is written and compiled as if it is loaded at address zero. However, when a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value. In the example above, the OS decides to load the process at physical address $3 2 \mathrm { K B }$ and thus sets the base register to this value.  

Interesting things start to happen when the process is running. Now, when any memory reference is generated by the process, it is translated by the processor in the following manner:  

physical address $\mathbf { \Sigma } = \mathbf { \Sigma }$ virtual address $^ +$ base  

Each memory reference generated by the process is a virtual address; the hardware in turn adds the contents of the base register to this address and the result is a physical address that can be issued to the memory system.  

To understand this better, let’s trace through what happens when a single instruction is executed. Specifically, let’s look at one instruction from our earlier sequence:  

128: movl 0x0(%ebx), %eax  

The program counter (PC) is set to 128; when the hardware needs to fetch this instruction, it first adds the value to the base register value of 32 KB (32768) to get a physical address of 32896; the hardware then fetches the instruction from that physical address. Next, the processor begins executing the instruction. At some point, the process then issues  

OPERATINGSYSTEMS[VERSION 1.10]  

TIP: HARDWARE-BASED DYNAMIC RELOCATION With dynamic relocation, a little hardware goes a long way. Namely, a base register is used to transform virtual addresses (generated by the program) into physical addresses. A bounds (or limit) register ensures that such addresses are within the confines of the address space. Together they provide a simple and efficient virtualization of memory.  

the load from virtual address $1 5 \mathrm { K B }$ , which the processor takes and again adds to the base register (32 KB), getting the final physical address of 47 KB and thus the desired contents.  

Transforming a virtual address into a physical address is exactly the technique we refer to as address translation; that is, the hardware takes a virtual address the process thinks it is referencing and transforms it into a physical address which is where the data actually resides. Because this relocation of the address happens at runtime, and because we can move address spaces even after the process has started running, the technique is often referred to as dynamic relocation [M65].  

Now you might be asking: what happened to that bounds (limit) register? After all, isn’t this the base and bounds approach? Indeed, it is. As you might have guessed, the bounds register is there to help with protection. Specifically, the processor will first check that the memory reference is within bounds to make sure it is legal; in the simple example above, the bounds register would always be set to 16 KB. If a process generates a virtual address that is greater than (or equal to) the bounds, or one that is negative, the CPU will raise an exception, and the process will likely be terminated. The point of the bounds is thus to make sure that all addresses generated by the process are legal and within the “bounds” of the process, as you might have guessed.  

We should note that the base and bounds registers are hardware structures kept on the chip (one pair per CPU). Sometimes people call the part of the processor that helps with address translation the memory management unit (MMU); as we develop more sophisticated memorymanagement techniques, we will be adding more circuitry to the MMU.  

A small aside about bound registers, which can be defined in one of two ways. In one way (as above), it holds the size of the address space, and thus the hardware checks the virtual address against it first before adding the base. In the second way, it holds the physical address of the end of the address space, and thus the hardware first adds the base and then makes sure the address is within bounds. Both methods are logically equivalent; for simplicity, we’ll usually assume the former method.  

# Example Translations  

To understand address translation via base-and-bounds in more detail, let’s take a look at an example. Imagine a process with an address space of size $4 \mathrm { K B }$ (yes, unrealistically small) has been loaded at physical address 16 KB. Here are the results of a number of address translations:  

<html><body><table><tr><td>Virtual Address</td><td>Physical Address</td></tr><tr><td>0</td><td>16 KB</td></tr><tr><td>1 KB</td><td>17 KB</td></tr><tr><td>3000</td><td>19384</td></tr><tr><td>4400</td><td>Fault (out of bounds)</td></tr></table></body></html>  

As you can see from the example, it is easy for you to simply add the base address to the virtual address (which can rightly be viewed as an offset into the address space) to get the resulting physical address. Only if the virtual address is ${ } ^ { \prime \prime } \mathrm { t o o ~ b i g } ^ { \prime \prime }$ or negative will the result be a fault, causing an exception to be raised.  

