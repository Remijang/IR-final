4.3.1 Arrays

Array Specific Features

Note that the starting memory location of entry  is equal to the base address of the array plus  in an array with word (4 byte) sized elements. In a high level language, the programmer always specifies the index in an array, and relies on the compiler to multiply the index by 4. ARM assembly provides nice features to multiply  by 4 by using the  instruction. This feature can be embedded in load-store instructions.

ldr r0, [r1, r2, lsl #2]

In this case the base address is stored in register, r1, and the offset is equal to   . The advantage here is that we do not need a separate instruction to multiply the index by 4. We have already seen this optimization in Section 4.2.2. However, there are other optimizations that can make our life easier. Let us consider array accesses in a loop as shown in Example 48.

Example 48 Convert the following  program to a program to ARM assembly. Assume that the base address of the array is stored in  .

Answer:

There is a scope for added efficiency here. We note that Lines 6 and 7 form a standard pattern. Line 6 reads the array entry, and Line 7 increments the index. Almost all sequential array accesses follow a similar pattern. Hence, it makes sense to have one instruction that simplifies this process.

The ARM architecture adds two extra addressing modes for the load and store instructions to achieve this. They are called pre-indexed and post-indexed with auto-update. In the preindexed addressing mode (with auto-update), the base address is updated first, and then the effective memory address is computed. In a post-indexed scheme, the base address is updated after the effective address is computed.

The pre-indexed addressing mode with auto-update is implemented by adding a ‘!’ sign after the address.

Examples of the pre-indexed addressing mode ldr r  ldr r

The post-indexed addressing mode is implemented by encapsulating the base address within ‘[’ and ‘]’, and writing the offset arguments separated by commas after it.

Examples of the post-indexed addressing mode ldr r3,  ldr r3,

Let us now see, how we can slightly make our addNumbers slightly more intuitive. The modified ARM code is shown in Example 49.

Example 49   
Convert the assembly code shown in Example 48 to use the post indexed addressing mode. Answer: ARM assembly   
/\* base address of array a in r0 \*/ mov r1, #0 /\* sum = 0 \*/ add r4, r0, #400 /\* address of a[100]\*/   
.loop: ldr r3, [r0], #4 add r1, r1, r3 /\* sum += a[idx] \*/ cmp r0, r4 bne .loop

We have eliminated the index variable saved in  . It is not required anymore. We directly update the base address in Line 5. For the loop exit condition, we compute the first address beyond the end of the array in Line 3. We compare the base address with this illegal address in Line 7, and then if they are unequal we keep iterating.

Example 48 contains 5 lines in the loop, whereas the code in Example 49 contains 4 lines in the loop. We have thus shown that it is possible to reduce the code size (of the loop) by  using post-indexed addressing, and increase performance too since most cores do not impose additional time overheads when auto-update addressing modes are used.

Structures

Implementing structures is very similar to implementing arrays. Let us look at a typical structure in C.

struct Container { int a; int b; char c; short int d; int e;   
};

We can treat each structure as an array. Consequently, a structure will have a base address and each element of the structure will have an offset. Unlike an array, different elements in a structure can have different sizes, and thus they are not constrained to start with offsets that are multiples of the word size.

Table 4.15 shows the offsets for different elements within a structure (as generated by the GNU ARM compiler). We need to note that compilers for the ARM architecture impose additional constraints. They pad variable addresses, and align them with 2-byte or 4-byte boundaries as shown in Table 4.15 The rules for variable alignment are described in detail in the ARM architecture manual [arm, 2000]. Similarly, it is possible to implement more high level data structures such as unions and classes. The interested reader is referred to a book on compilers[Aho et al., 2006].