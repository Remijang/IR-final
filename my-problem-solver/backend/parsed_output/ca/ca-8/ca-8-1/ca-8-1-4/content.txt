8.1.4 Carry Select Adder

A ripple carry adder is extremely slow for large values of  such as 32 or 64. Consequently, we desire faster implementations. We observe that in hardware we can potentially do a lot of tasks in parallel. Unlike purely sequential C or Java programs where one statement executes after the next, hundreds or even thousands of actions can be performed in parallel in hardware. Let us use this insight to design a faster adder that runs in  time.

Let us consider the problem of adding two numbers  and  represented as  and  , respectively. We start by dividing the set of bits into blocks of letâ€™s say 4 bits. The blocks are shown in Figure 8.6. Each block contains a fragment of  and a fragment of  . We need to add the two fragments by considering the input carry to the block, and generate a set of sum bits and a carry out. This carry out is an input carry for the subsequent block.

In this case, a carry is propagated between blocks rather that between bit pairs. To add the pair of fragments within a block, we can use a simple ripple carry adder. For small values of  , ripple carry adders are not very inefficient. However, our basic problem of carry propagation has not been solved yet.

Let us now introduce the basic idea of the carry select adder. We divide the computation into two stages. In the first stage, we generate two results for each block. One result assumes that the input carry is 0, and the other result assumes that the input carry is 1. A result consists of 4 sum bits, and a carry out. We thus require two ripple carry adders per block. Note that each of these additions are independent of each other and thus can proceed in parallel.

Now, at the beginning of the second stage two sets of results for the  block are ready. If we know the value of the input carry,  produced by the  block, then we can quickly calculate the value of the output carry,  , by using a simple multiplexer. We do not need to perform any extra additions. The inputs to the multiplexer are the values of  generated by the two ripple carry adders that assume  to be 0 and 1, respectively. When the correct value of  is available, it can be used to choose between the two values of  . This process is much faster than adding the two blocks. Simultaneously, we can also choose the right set of sum bits. Then we need to propagate the output carry,  , to the  block.

Let us now evaluate the time complexity of the carry select adder. Let us generalize the problem and assume the block size to be  . The first stage takes  time because we add each pair of fragments within a block using a regular ripple carry adder, and all the pairs of fragments are added in parallel. The second phase takes time  . This is because we have  blocks, and we assume that it takes 1 time unit for the input carry of a block to choose the right output carry in the multiplexer. The total time is thus:  . Note that we are making some simplistic assumptions regarding the constants. However, our final answer will not change if we make our model more complicated.

Let us now try to minimize the time taken. This can be done as follows:

Thus, the optimal block size is equal to  . The total time complexity is thus  , which is the same as  .