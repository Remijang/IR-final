9.2.4 Execute Unit

Let us now look at executing an instruction. Let us start out by dividing instructions into two types – branch and non-branch. Branch instructions are handled by a dedicated branch unit that computes the outcome, and final target of the branch. Non branch instructions are handled by an ALU (arithmetic logic unit).

Branch Unit

The circuit for the branch unit is shown in Figure 9.8.

First, we use a multiplexer to choose between the value of the return address (op1), and the branchT arget embedded in the instruction. The isRet signal controls the multiplexer. If it is equal to 1, we choose op1; otherwise, we choose branchT arget. The output of the multiplexer, branchP C, is sent to the fetch unit.

Now, let us consider the circuit to compute the branch outcome. As an example, let us consider the case of the beq instruction. Recall that the SimpleRisc instruction set requires a f lags register that contains the result of the last compare  instruction. It has two bits  and  . If the last compare instruction led to an equality, then the  bit is set, and if the first operand was greater than the second operand then the  bit is set. For the beq instruction, the control unit sets the signal  to 1. We need to compute a logical AND of this signal and the value of the  bit in the f lags register. If both are 1, then the branch is taken. Similarly, we need an AND gate to compute the outcome of the bgt instruction, as shown in Figure 9.8. The branch might also be unconditional  . In this case, the control unit sets the signal isU Branch to 1. If any of the above conditions is true, then the branch is taken. We subsequently use an OR gate that computes the outcome of the branch, and sets the isBranchT aken signal. This signal is used by the fetch unit to control the multiplexer that generates the next PC.

ALU

Figure 9.9 shows the part of the execution unit that contains the ALU. The first operand  of the ALU is always op1 (obtained from the operand fetch unit). However, the second operand (  ) can either be a register or the sign extended immediate. This is decided by the isImmediate signal generated by the control unit. The isImmediate signal is equal to the value of the immediate bit in the instruction. If it is 1, then the multiplexer in Figure 9.9 chooses immx as the operand. If it is 0, then op2 is chosen as the operand. The ALU takes as input a set of signals known collectively as aluSignals. They are generated by the control unit, and specify the type of ALU operation. The result of the ALU is termed as aluResult.

Figure 9.10 shows the design of the ALU. The ALU contains a set of modules. Each module computes a separate arithmetic or logical function such as addition or division. Secondly, each module has a dedicated signal that enables or disables it. For example, there is no reason to enable the divider when we want to perform simple addition. There are several ways in which we can enable or disable a unit. The simplest method is to use a transmission gate for every input bit. A transmission gate is shown in Figure 9.11. If the signal(S) is turned on, then the output reflects the value of the input. Otherwise, it maintains its previous value. Thus, if the enabling signal is off, then the module does not see the new inputs. It thus does not dissipate any power, and is effectively disabled.

Let us consider each of the modules in the ALU one after another. The most commonly used module is the adder. It is used by add, sub, and cmp instructions, as well as by load and store instructions to compute the memory address. It takes  and  as inputs. Here,  and  are the values of the source operands. If the isAdd signal is turned on, then the adder adds the operands. Likewise, if the  signal is turned on, then the adder adds the 2’s complement of  with  . In effect, it subtracts  from  . If the isCmp flag is turned on, then the adder unit subtracts  from  and sets the value of the f lags register. If the output is 0, then it sets the  bit. If the output is positive, it sets the  bit. If none of these signals (isAdd/isSub/isCmp) is true, then the adder is disabled.

The multiplier and divider functions are implemented similarly. The multiplier is enabled by the isMul signal, and the divider is enabled by the  or isM od signals. If the isDiv signal is true, then the result is the quotient of the division, whereas, if the isM od signal is true, the result is the remainder of the division.

The shift unit left shifts, or right shifts  , by  positions. It takes three signals – isLsl,  , and isAsr. The logical unit consists of a set of AND, OR, and NOT gates. They are enabled by the signals isOr, isAnd, and isNot, respectively. The Mov unit is slightly special

in the sense that it is the simplest. If the isM ov signal is true, then the output is equal to  .   
Otherwise, it is disabled.

To summarize, we show the full design of the execution unit (branch unit and ALU) in Figure 9.12. To set the output (aluResult), we need a multiplexer that can choose the right output out of all the modules in the ALU. We do not show this multiplexer in Figure 9.12. We leave the detailed design of the ALU circuit along with the transmission gates and output multiplexer as an exercise for the reader.