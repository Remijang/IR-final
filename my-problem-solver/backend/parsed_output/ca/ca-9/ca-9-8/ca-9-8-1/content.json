[
    {
        "type": "text",
        "text": "9.8.1 Vertical Microprogramming ",
        "text_level": 1,
        "page_idx": 405
    },
    {
        "type": "text",
        "text": "In vertical microprogramming, we encode an instruction similar to encoding a regular RISC instruction in a hardwired processor. ",
        "page_idx": 405
    },
    {
        "type": "image",
        "img_path": "images/b494103e9fae764028965b979e3085ef9dae518ce6af70b7c7ddec5ee4d0db5f.jpg",
        "img_caption": [
            "Figure 9.24: Encoding of a microinstruction (vertical microprogramming) "
        ],
        "img_footnote": [],
        "page_idx": 405
    },
    {
        "type": "text",
        "text": "Figure 9.24 shows an encoding for our scheme. Here, we devote 3 bits for encoding the type of the microinstruction. We need 3 bits because we have a total of 8 microinstructions (see Table 9.8). Each microinstruction embeds the 5 bit id (because we have 19 registers visible to microprograms) of an internal source register, 5 bit id of an internal destination register, a 12-bit immediate, and a 10-bit branch target. At the end, we encode a 10-bit args value in the microinstruction. Each instruction thus requires 45 bits. ",
        "page_idx": 405
    },
    {
        "type": "text",
        "text": "Now, to process a vertically encoded microinstruction, we need a dedicated \u00b5decode unit that can generate all the control signals. These signals include all the enable signals for the internal registers, and the signals to select the right input in the transfer multiplexer. Additionally, it needs to extract some fields from the microinstruction such as the immediate, branch target, and the args value, and subsequently extend their sign. We have already gone through a similar exercise for extracting the fields of an instruction, and generating control signals, when we discussed the operand fetch unit and control unit for our hardwired processors in Sections 9.2.3, and 9.3, respectively. The logic for generating the control signals, and extracting fields from the microinstruction is exactly the same. Hence, we leave the detailed design of these units as an exercise for the reader. ",
        "page_idx": 405
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 406
    },
    {
        "type": "image",
        "img_path": "images/b2329ddbfe21f66c6e24ef66e9615613012a94c9ab7d59e71abc6b77667d418b.jpg",
        "img_caption": [
            "Figure 9.25: The \u00b5control unit (vertical microprogramming) "
        ],
        "img_footnote": [],
        "page_idx": 406
    },
    {
        "type": "text",
        "text": "The design of the vertical \u00b5control unit is shown in Figure 9.25. We have a microPC $( \\mu p c )$ , which saves the index of the currently executing microinstruction. Every cycle, we increment the \u00b5pc by 1. This is because each row of the microprogram memory saves 1 microinstruction. We assume that a row is wide enough to save the entire contents of the microinstructions. We do not have the requirement of saving data at the granularity of a fixed number of bytes here. After reading the microinstruction, we proceed to decode it. The process of decoding a microinstruction breaks it into a set of fields (instruction type, immediate, branch target, args, source, and destination registers). Subsequently, we generate all the control signals and dispatch the set of control signals to the execute unit. The execute unit sets all the control signals, and orchestrates an operation in the data path of the processor. The execute unit also sets the control signals of the transfer multiplexer. We need some additional support to process the mswitch instruction. We add a dedicated switch unit that takes inputs (the opcode) from the $_ { i r }$ register, and computes the starting address for the microcode of the currently executing program instruction. It sends the address to the multiplexer, \u00b5fetch (see Figure 9.25). The multiplexer chooses between three inputs \u2013 default microPC, branch target, and the address generated by the switch unit. It is controlled by the execute unit. The rules for choosing the input are shown in Table 9.9. In accordance with these rules, and the value of the isMBranch signal (generated by comparing \u00b5imm, and the contents of the shared bus), the execute unit generates the control signals for the \u00b5f etch multiplexer. ",
        "page_idx": 406
    },
    {
        "type": "table",
        "img_path": "images/a4ac81b859c0d1343bb8f46a4a180913c067992b96c3fc2b344a3f0a33f6e260.jpg",
        "table_caption": [
            "Table 9.9: Rules for controlling the \u00b5fetch multiplexer "
        ],
        "table_footnote": [],
        "table_body": "\n\n<html><body><table><tr><td>Instruction</td><td>Output of the \u03bcfetch multiplexer</td><td></td></tr><tr><td>mloadIR</td><td>next \u03bcpc</td><td></td></tr><tr><td>mdecode</td><td>next \u03bcpc</td><td></td></tr><tr><td>mswitch</td><td>output of the switch unit</td><td></td></tr><tr><td>mmov</td><td>next \u03bcpc</td><td></td></tr><tr><td>mmovi</td><td>next \u03bcpc</td><td></td></tr><tr><td>madd</td><td></td><td></td></tr><tr><td>mb</td><td>next \u03bcpc branch target</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>mbeq</td><td>branch target if isMBranch = 1, else next \u03bcpc</td><td></td></tr></table></body></html>\n\n",
        "page_idx": 407
    }
]