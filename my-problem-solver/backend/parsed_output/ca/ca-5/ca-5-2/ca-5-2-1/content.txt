5.2.1 Integer Registers

Figure 5.1 shows the x86 register set. The 16 and 32-bit x86 ISAs have 8 general purpose registers. These registers have an interesting history. The original 8080 microprocessor designed forty years ago had seven 8-bit general purpose registers namely  ,  ,  ,  ,  ,  and  . In the late seventies, x86 designers decided to create a 16-bit processor called 8086. They decided to keep four registers (  , b, c, and  ), and suffixed them with the ’x’ tag (’x’ for extended). Thus, the four general purpose registers got renamed to  ,  ,  , and  . Additionally, the designers of the 8086 machine decided to retain some 16-bit registers namely the stack pointer  , and the register to save the PC  . The designers also introduced three extra registers in their design – bp (base pointer),  (starting index), and di (destination index). The intention of adding the bp register was to save the value of the stack pointer at the beginning of a function. Compilers are expected to set  equal to  at the end of the function. This operation destroys the stack frame of the callee function. The registers  , and  are used by the rep instruction that repeats a certain operation. Typically, a single rep instruction is equivalent to a simple for loop. Thus, the 8086 processor had eight 16-bit general purpose registers –  ,  , cx, dx,  , bp, si, and  . It was further possible to access the two bytes (lower and upper) in the registers  . For example, the lower byte in the  register can be addressed as  , and the upper byte can be addressed as  . 16-bit x86 instructions can use combinations of 8-bit and 16-bit operands.

The 8086 processor had two special purpose registers. The first register called  contained the PC. The PC is typically not accessible to programmers on x86 machines (unlike the ARM ISA). The second special purpose register is the f lags register that saves the results of the last comparison (similar to the f lags register in ARM and SimpleRisc ). The f lags register is used by subsequent conditional branch instructions to compute the outcome of the branch.

In the mid-eighties, when Intel decided to extend the 8086 design to support 32-bit registers, it decided to keep the same set of registers (8 general purpose  , and similar nomenclature. However, it extended their names by adding an ’e’ prefix. Thus, in a 32-bit machine, register eax is the 32-bit version of  . To maintain backward compatibility with the 8086, the lower 16 bits of eax can be addressed as  (if we wish to use 16-bit operands). Furthermore, the two bytes in  can be addressed as ah and al (similar to 8086). As shown in Figure 5.1, the names were changed for all the other registers also. Notably, in a 32-bit machine, the stack pointer is stored in  , the PC is stored in  , and the flags are stored in the ef lags register.

There are many advantages to this strategy. The first is that 8086 code can run on a 32-bit x86 processor seamlessly. All of its registers are defined in the 32-bit ISA. This is because each 16-bit register is represented by the lower 16 bits of a 32-bit register. Hence, there are no issues with backward compatibility. Secondly, we do not need to add new registers, because we simply extend each 16-bit register with 16 additional bits. We refer to the new register with a new name (16-bit name prefixed with ’e’).

Exactly the same pattern was followed while extending the x86 ISA to create the 64-bit x86-64 ISA. The first letter was replaced from ’e’ to ’r’ to convert a 32-bit register to a 64-bit register. For example, the register rax is the 64-bit version of  . Its lower 32 bits can be addressed as eax. The connotation of ax, ah, and al remains the same as before. Additionally, the x86-64 ISA introduced 8 more general purpose registers namely  . However, their subfields cannot be addressed directly. The 64-bit PC is saved in the rip register, and the flags are stored in the rf lags register.

The eflags register

Let us now quickly discuss the structure of the eflags register. Like ARM and x86, the flags register contains a set of fields, where each field or bit indicates the status of the execution of the instruction that last set it. It is called ef lags in 32-bit x86. Table 5.1 lists some of the most commonly used fields in the eflags register, along with their semantics.